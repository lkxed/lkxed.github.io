<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kafka 性能测试脚本：简介与使用｜六开箱</title><meta name=keywords content="消息队列,Kafka,性能测试,test,脚本,producer,consumer,工具,简介,使用,教程"><meta name=description content="使用 Kafka 官方提供的性能测试脚本 kafka-producer-perf-test.sh 和 kafka-consumer-perf-test.sh，获取集群的吞吐量和时延信息。"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/kafka-perf-test-scripts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="Kafka 性能测试脚本：简介与使用"><meta property="og:description" content="使用 Kafka 官方提供的性能测试脚本 kafka-producer-perf-test.sh 和 kafka-consumer-perf-test.sh，获取集群的吞吐量和时延信息。"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/kafka-perf-test-scripts/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-25T18:04:19+08:00"><meta property="article:modified_time" content="2021-03-25T18:04:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kafka 性能测试脚本：简介与使用"><meta name=twitter:description content="使用 Kafka 官方提供的性能测试脚本 kafka-producer-perf-test.sh 和 kafka-consumer-perf-test.sh，获取集群的吞吐量和时延信息。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kafka 性能测试脚本：简介与使用","item":"https://lkxed.github.io/posts/kafka-perf-test-scripts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kafka 性能测试脚本：简介与使用","name":"Kafka 性能测试脚本：简介与使用","description":"使用 Kafka 官方提供的性能测试脚本 kafka-producer-perf-test.sh 和 kafka-consumer-perf-test.sh，获取集群的吞吐量和时延信息。","keywords":["消息队列","Kafka","性能测试","test","脚本","producer","consumer","工具","简介","使用","教程"],"articleBody":" 使用 Kafka 官方提供的性能测试脚本 kafka-producer-perf-test.sh 和 kafka-consumer-perf-test.sh，获取集群的吞吐量和时延信息。\n 介绍 Apache Kafka 官方提供了两个客户端性能测试脚本，它们的存放位置如下：\n 生产者性能测试脚本：$KAFKA_HOME/bin/kafka-producer-perf-test.sh 消费者性能测试脚本：$KAFKA_HOME/bin/kafka-consumer-perf-test.sh  kafka-producer-perf-test.sh 支持测试的性能指标包括：吞吐量（throughput）、最大时延（max-latency）、平均时延（avg-latency）；kafka-consumer-perf-test.sh 同样支持吞吐量指标，还提供了一些消费端特有的指标，但没有直接提供时延信息。\n使用 使用测试性能脚本之前，我们需要了解它们支持的参数及其含义。\nkafka-producer-perf-test.sh 此脚本用于测试 Kafka 生产消息的性能，可选参数列表如下，加粗项为常用参数。\n   参数名 含义     -h, –help 显示使用帮助并退出   –topic 指定生产的消息发往的 topic   –num-records 指定生产的消息总数   –payload-delimeter 如果通过 --payload-file 指定了从文件中获取消息内容，那么这个参数的意义是指定文件的消息分隔符，默认值为 \\n，即文件的每一行视为一条消息；如果未指定 --payload-file 则此参数不生效   –throughput 限制每秒发送的最大的消息数，设为 -1 表示不限制   –producer-props 直接指定 Producer 配置，格式为 NAME=VALUE，例如 bootstrap.server=127.0.0.1:9092，通过此种方式指定的配置优先级高于 --producer.config   –producer-config 指定 Producer 的配置文件，格式参照官方的 config/producer.properties   –print-metrics 在测试结束后打印更详尽的指标，默认为 false   –transactional-id 指定事务 ID，测试并发事务的性能时需要，只有在 –transaction-duration-ms  0 时生效，默认值为 performance-producer-default-transactional-id   –transactional-duration-ms 指定事务持续的最长时间，超过这段时间后就会调用 commitTransaction 来提交事务，只有指定了  0 的值才会开启事务，默认值为 0   –record-size 指定每条消息的大小，单位是字节，和 --payload-file 两个中必须指定一个，但不能同时指定   –payload-file 指定消息的来源文件，只支持 UTF-8 编码的文本文件，文件的消息分隔符通过 --payload-delimeter 指定，和 --record-size 两个中必须指定一个，但不能同时指定    【示例】\nbin/kafka-producer-perf-test.sh --topic perf-test --num-records 1000 --record-size 1024 --throughput -1 --producer-props bootstrap.servers=127.0.0.1:9092 compression.type=lz4 【输入解释】 发送 1000 条大小为 1KB 的消息到地址为 127.0.0.1:9092 的 broker 上的 perf-test 主题，发送时不限制吞吐量，并使用 lz4 算法压缩消息。\n执行示例命令后，控制台输出一行测试结果，如下：\n1000 records sent, 3424.657534 records/sec (3.34 MB/sec), 13.61 ms avg latency, 255.00 ms max latency, 13 ms 50th, 20 ms 95th, 255 ms 99th. 【输出解释】 成功消费了 1000 条消息，吞吐量为 3424.657534 条/秒 (或 3.34 MB/秒)，平均时延为 13.61 ms，最大时延为 255.00 ms，50 % 的消息延时在 13 ms 内，95 % 的消息延时在 20 ms 内，99 % 的消息延时在 255 毫秒内。\nkafka-consumer-perf-test.sh 此脚本用于测试 Kafka 消费消息的性能，可选参数列表如下，加粗项为常用参数。\n   参数名 含义     –bootstrap-server 指定 broker 地址，必选，除非用 --broker-list 代替（不建议）   –topic 指定消费的 topic，必选   –version 输出 Kafka 版本   –consumer.config 指定 Consumer 配置文件   –date-format 指定用于格式化 *.time 的规则，默认为 yyyy-MM-dd HH:mm:ss:SSS   –fetch-size 指定一次请求消费的大小，默认为 1048576 即 1 MB   –from-latest 如果 Consumer 没有已经建立的 offset，则指定从 log 中最新的位点开始消费，而不是从最早的位点开始消费   –group 指定 ConsumerGroup ID，默认为 perf-consumer-40924   –help 显示使用帮助并退出   –hide-header 指定后不输出 header 信息   –messages 指定消费的消息数量，必选   –num-fetch-threads 指定 fetcher 线程的数量   –print-metrics 指定打印 metrics 信息   –reporting-interval 指定打印进度信息的时间间隔，默认为 5000 即 5 秒   –show-detailed-stats 指定每隔一段时间（由 --reporting-interval 指定）输出显示详细的状态信息   –socket-buffer-size 指定 TCP 的 RECV 大小，默认为 2097152 即 2 MB   –threads 指定消费的线程数，默认为 10   –timeout 指定允许的最大超时时间，即每条消息返回的最大时间间隔，默认为 10000 即 10 秒    【示例】\nbin/kafka-consumer-perf-test.sh --bootstrap-server 127.0.0.1:9092 --topic perf_test --messages 1000000 --threads 8 --reporting-interval 1000 --show-detailed 【输入解释】 同时开启 8 个消费线程，从 127.0.0.1:9092 的 broker 上的 perf-test 主题中消费 1000 条消息，每隔 1000 ms = 1 s 打印一次消费进度信息。最后两个参数在消费数量很小的场景下没有什么帮助，比如若消费数量只有 1000，命令瞬间就可以执行返回；但当指定的消费数量很大（如示例中为 1000 万）时，需要 10 s 左右才能消费完，此时定时输出一下进度信息就显得很有用了。\n执行示例命令后，控制台输出两行信息，其中第一行为表头，接下来的数行为每秒的进度信息，如下：\ntime, threadId, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec 2021-03-25 15:57:59:426, 0, 657.2275, 657.2275, 673001, 673001.0000, 1616659078690, -1616659077690, 0.0000, 0.0000 ... 【输出解释】\n time：当前时间，格式由 --date-format 指定 threadId：线程 ID data.consumed.in.MB：消费到的数据总大小，单位为 MB MB.sec：消费 TPS，即每秒消费的消息大小 data.consumed.in.nMsg：消费到的总消息数 nMsg.sec：消费 TPS，即每秒消费的消息条数 rebalance.time.ms：消费者组重平衡的耗时，单位为 ms，0 表示没有发生重平衡 fetch.time.ms：fetch 线程的总耗时，单位为 ms fetch.MB.sec：fetch 线程每秒钟获取到的消息大小 fetch.nMsg.sec：fetch 线程每秒钟获取到的消息数量  【注意】 若没有指定 --show-detailed，则输出信息中的前两项会有所不同，如下：\nstart.time, end.time, data.consumed.in.MB, MB.sec, ...  start.time：消费开始的时间，格式由 –date-format 指定 end.time：消费结束的时间，格式由 –date-format 指定    转载须知：本文使用 [CC BY-SA 4.0 国际协议][f] 进行许可\n作者：六开箱 链接：https://lkxed.github.io/posts/kafka-perf-test-scripts/  ","wordCount":"2079","inLanguage":"zh","datePublished":"2021-03-25T18:04:19+08:00","dateModified":"2021-03-25T18:04:19+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/kafka-perf-test-scripts/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Kafka 性能测试脚本：简介与使用</h1><div class=post-meta><span title="2021-03-25 18:04:19 +0800 CST">2021 年 3 月 25 日</span>&nbsp;·&nbsp;2079 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#%e4%bd%bf%e7%94%a8 aria-label=使用>使用</a><ul><li><a href=#kafka-producer-perf-testsh aria-label=kafka-producer-perf-test.sh>kafka-producer-perf-test.sh</a></li><li><a href=#kafka-consumer-perf-testsh aria-label=kafka-consumer-perf-test.sh>kafka-consumer-perf-test.sh</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>使用 Kafka 官方提供的性能测试脚本 <code>kafka-producer-perf-test.sh</code> 和 <code>kafka-consumer-perf-test.sh</code>，获取集群的吞吐量和时延信息。</p></blockquote><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>Apache Kafka 官方提供了两个客户端性能测试脚本，它们的存放位置如下：</p><ul><li>生产者性能测试脚本：<code>$KAFKA_HOME/bin/kafka-producer-perf-test.sh</code></li><li>消费者性能测试脚本：<code>$KAFKA_HOME/bin/kafka-consumer-perf-test.sh</code></li></ul><p><code>kafka-producer-perf-test.sh</code> 支持测试的性能指标包括：吞吐量（throughput）、最大时延（max-latency）、平均时延（avg-latency）；kafka-consumer-perf-test.sh 同样支持吞吐量指标，还提供了一些消费端特有的指标，但没有直接提供时延信息。</p><h2 id=使用>使用<a hidden class=anchor aria-hidden=true href=#使用>#</a></h2><p>使用测试性能脚本之前，我们需要了解它们支持的参数及其含义。</p><h3 id=kafka-producer-perf-testsh>kafka-producer-perf-test.sh<a hidden class=anchor aria-hidden=true href=#kafka-producer-perf-testsh>#</a></h3><p>此脚本用于测试 Kafka <strong>生产</strong>消息的性能，可选参数列表如下，<strong>加粗项</strong>为常用参数。</p><table><thead><tr><th style=text-align:left>参数名</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left>-h, &ndash;help</td><td style=text-align:left>显示使用帮助并退出</td></tr><tr><td style=text-align:left><strong>&ndash;topic</strong></td><td style=text-align:left>指定生产的消息发往的 topic</td></tr><tr><td style=text-align:left><strong>&ndash;num-records</strong></td><td style=text-align:left>指定生产的消息总数</td></tr><tr><td style=text-align:left>&ndash;payload-delimeter</td><td style=text-align:left>如果通过 <code>--payload-file</code> 指定了从文件中获取消息内容，那么这个参数的意义是指定文件的消息分隔符，默认值为 <code>\n</code>，即文件的每一行视为一条消息；如果未指定 <code>--payload-file</code> 则此参数不生效</td></tr><tr><td style=text-align:left><strong>&ndash;throughput</strong></td><td style=text-align:left>限制每秒发送的最大的消息数，设为 <code>-1</code> 表示不限制</td></tr><tr><td style=text-align:left><strong>&ndash;producer-props</strong></td><td style=text-align:left>直接指定 Producer 配置，格式为 <em>NAME=VALUE</em>，例如 <code>bootstrap.server=127.0.0.1:9092</code>，通过此种方式指定的配置优先级高于 <code>--producer.config</code></td></tr><tr><td style=text-align:left>&ndash;producer-config</td><td style=text-align:left>指定 Producer 的配置文件，格式参照官方的 <code>config/producer.properties</code></td></tr><tr><td style=text-align:left>&ndash;print-metrics</td><td style=text-align:left>在测试结束后打印更详尽的指标，默认为 <code>false</code></td></tr><tr><td style=text-align:left>&ndash;transactional-id</td><td style=text-align:left>指定事务 ID，测试并发事务的性能时需要，只有在 &ndash;transaction-duration-ms > 0 时生效，默认值为 <code>performance-producer-default-transactional-id</code></td></tr><tr><td style=text-align:left>&ndash;transactional-duration-ms</td><td style=text-align:left>指定事务持续的最长时间，超过这段时间后就会调用 <code>commitTransaction</code> 来提交事务，只有指定了 <code>> 0</code> 的值才会开启事务，默认值为 <code>0</code></td></tr><tr><td style=text-align:left><strong>&ndash;record-size</strong></td><td style=text-align:left>指定每条消息的大小，单位是字节，和 <code>--payload-file</code> 两个中必须指定一个，但不能同时指定</td></tr><tr><td style=text-align:left>&ndash;payload-file</td><td style=text-align:left>指定消息的来源文件，只支持 UTF-8 编码的文本文件，文件的消息分隔符通过 <code>--payload-delimeter</code> 指定，和 <code>--record-size</code> 两个中必须指定一个，但不能同时指定</td></tr></tbody></table><p>【示例】</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>bin/kafka-producer-perf-test.sh --topic perf-test --num-records <span class=m>1000</span> --record-size <span class=m>1024</span> --throughput -1 --producer-props bootstrap.servers<span class=o>=</span>127.0.0.1:9092 compression.type<span class=o>=</span>lz4
</span></span></code></pre></div><p>【输入解释】
发送 1000 条大小为 1KB 的消息到地址为 127.0.0.1:9092 的 broker 上的 perf-test 主题，发送时不限制吞吐量，并使用 lz4 算法压缩消息。</p><p>执行示例命令后，控制台输出一行测试结果，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=m>1000</span> records sent, 3424.657534 records/sec <span class=o>(</span>3.34 MB/sec<span class=o>)</span>, 13.61 ms avg latency, 255.00 ms max latency, <span class=m>13</span> ms 50th, <span class=m>20</span> ms 95th, <span class=m>255</span> ms 99th.
</span></span></code></pre></div><p>【输出解释】
成功消费了 1000 条消息，吞吐量为 3424.657534 条/秒 (或 3.34 MB/秒)，平均时延为 13.61 ms，最大时延为 255.00 ms，50 % 的消息延时在 13 ms 内，95 % 的消息延时在 20 ms 内，99 % 的消息延时在 255 毫秒内。</p><h3 id=kafka-consumer-perf-testsh>kafka-consumer-perf-test.sh<a hidden class=anchor aria-hidden=true href=#kafka-consumer-perf-testsh>#</a></h3><p>此脚本用于测试 Kafka <strong>消费</strong>消息的性能，可选参数列表如下，<strong>加粗项</strong>为常用参数。</p><table><thead><tr><th><strong>参数名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>&ndash;bootstrap-server</strong></td><td>指定 broker 地址，必选，除非用 <code>--broker-list</code> 代替（不建议）</td></tr><tr><td><strong>&ndash;topic</strong></td><td>指定消费的 topic，必选</td></tr><tr><td>&ndash;version</td><td>输出 Kafka 版本</td></tr><tr><td><strong>&ndash;consumer.config</strong></td><td>指定 Consumer 配置文件</td></tr><tr><td>&ndash;date-format</td><td>指定用于格式化 *<em>.time</em> 的规则，默认为 <code>yyyy-MM-dd HH:mm:ss:SSS</code></td></tr><tr><td><strong>&ndash;fetch-size</strong></td><td>指定一次请求消费的大小，默认为 <code>1048576</code> 即 1 MB</td></tr><tr><td>&ndash;from-latest</td><td>如果 Consumer 没有已经建立的 offset，则指定从 log 中最新的位点开始消费，而不是从最早的位点开始消费</td></tr><tr><td>&ndash;group</td><td>指定 ConsumerGroup ID，默认为 <code>perf-consumer-40924</code></td></tr><tr><td>&ndash;help</td><td>显示使用帮助并退出</td></tr><tr><td>&ndash;hide-header</td><td>指定后不输出 header 信息</td></tr><tr><td><strong>&ndash;messages</strong></td><td>指定消费的消息数量，必选</td></tr><tr><td>&ndash;num-fetch-threads</td><td>指定 fetcher 线程的数量</td></tr><tr><td>&ndash;print-metrics</td><td>指定打印 metrics 信息</td></tr><tr><td><strong>&ndash;reporting-interval</strong></td><td>指定打印进度信息的时间间隔，默认为 <code>5000</code> 即 5 秒</td></tr><tr><td><strong>&ndash;show-detailed-stats</strong></td><td>指定每隔一段时间（由 <code>--reporting-interval</code> 指定）输出显示详细的状态信息</td></tr><tr><td>&ndash;socket-buffer-size</td><td>指定 TCP 的 RECV 大小，默认为 <code>2097152</code> 即 2 MB</td></tr><tr><td><strong>&ndash;threads</strong></td><td>指定消费的线程数，默认为 <code>10</code></td></tr><tr><td>&ndash;timeout</td><td>指定允许的最大超时时间，即每条消息返回的最大时间间隔，默认为 <code>10000</code> 即 10 秒</td></tr></tbody></table><p>【示例】</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>bin/kafka-consumer-perf-test.sh --bootstrap-server 127.0.0.1:9092 --topic perf_test --messages <span class=m>1000000</span> --threads <span class=m>8</span> --reporting-interval <span class=m>1000</span> --show-detailed
</span></span></code></pre></div><p>【输入解释】
同时开启 8 个消费线程，从 127.0.0.1:9092 的 broker 上的 perf-test 主题中消费 1000 条消息，每隔 1000 ms = 1 s 打印一次消费进度信息。最后两个参数在消费数量很小的场景下没有什么帮助，比如若消费数量只有 1000，命令瞬间就可以执行返回；但当指定的消费数量很大（如示例中为 1000 万）时，需要 10 s 左右才能消费完，此时定时输出一下进度信息就显得很有用了。</p><p>执行示例命令后，控制台输出两行信息，其中第一行为表头，接下来的数行为每秒的进度信息，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>time, threadId, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec
</span></span><span class=line><span class=cl>2021-03-25 15:57:59:426, 0, 657.2275, 657.2275, 673001, 673001.0000, 1616659078690, -1616659077690, 0.0000, 0.0000
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>【输出解释】</p><ul><li>time：当前时间，格式由 <code>--date-format</code> 指定</li><li>threadId：线程 ID</li><li>data.consumed.in.MB：消费到的数据总大小，单位为 MB</li><li>MB.sec：消费 TPS，即每秒消费的消息大小</li><li>data.consumed.in.nMsg：消费到的总消息数</li><li>nMsg.sec：消费 TPS，即每秒消费的消息条数</li><li>rebalance.time.ms：消费者组重平衡的耗时，单位为 ms，0 表示没有发生重平衡</li><li>fetch.time.ms：fetch 线程的总耗时，单位为 ms</li><li>fetch.MB.sec：fetch 线程每秒钟获取到的消息大小</li><li>fetch.nMsg.sec：fetch 线程每秒钟获取到的消息数量</li></ul><p>【注意】
若没有指定 <code>--show-detailed</code>，则输出信息中的前两项会有所不同，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>start.time, end.time, data.consumed.in.MB, MB.sec, ...
</span></span></code></pre></div><ul><li>start.time：消费开始的时间，格式由 &ndash;date-format 指定</li><li>end.time：消费结束的时间，格式由 &ndash;date-format 指定</li></ul><hr><blockquote><p>转载须知：本文使用 [CC BY-SA 4.0 国际协议][f] 进行许可<br>作者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>链接：<a href=https://lkxed.github.io/posts/kafka-perf-test-scripts/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/kafka-perf-test-scripts/</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>消息队列</a></li><li><a href=https://lkxed.github.io/tags/kafka/>Kafka</a></li><li><a href=https://lkxed.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a></li><li><a href=https://lkxed.github.io/tags/%E8%84%9A%E6%9C%AC/>脚本</a></li><li><a href=https://lkxed.github.io/tags/%E5%B7%A5%E5%85%B7/>工具</a></li><li><a href=https://lkxed.github.io/tags/%E7%AE%80%E4%BB%8B/>简介</a></li><li><a href=https://lkxed.github.io/tags/%E4%BD%BF%E7%94%A8/>使用</a></li><li><a href=https://lkxed.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/5-git-commands/><span class=title>« 上一页</span><br><span>五个提升你的 Git 水平的小技巧</span></a>
<a class=next href=https://lkxed.github.io/posts/maven-plugin-shade/><span class=title>下一页 »</span><br><span>maven-plugin-shade：简介与使用</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>