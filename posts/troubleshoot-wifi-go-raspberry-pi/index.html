<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 Go 和树莓派排查 WiFi 问题｜六开箱</title><meta name=keywords content="Go,树莓派,WiFi,扫描器"><meta name=description content="实现一个 WiFi 扫描器玩玩～"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="使用 Go 和树莓派排查 WiFi 问题"><meta property="og:description" content="实现一个 WiFi 扫描器玩玩～"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T08:50:37+08:00"><meta property="article:modified_time" content="2022-05-08T08:50:37+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 Go 和树莓派排查 WiFi 问题"><meta name=twitter:description content="实现一个 WiFi 扫描器玩玩～"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用 Go 和树莓派排查 WiFi 问题","item":"https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 Go 和树莓派排查 WiFi 问题","name":"使用 Go 和树莓派排查 WiFi 问题","description":"实现一个 WiFi 扫描器玩玩～","keywords":["Go","树莓派","WiFi","扫描器"],"articleBody":" 实现一个 WiFi 扫描器玩玩～\n 前言 去年夏天，我和妻子变卖了家产，带着我们的两只狗移居了夏威夷。这里有美丽的阳光、温暖的沙滩、凉爽的冲浪等你能想到的一切。我们同样遇到了一些意料之外的事：WiFi 问题。\n不过，这不是夏威夷的问题，而是我们租住公寓的问题。我们住在一个单身公寓里，与房东的公寓仅一墙之隔。我们的租房协议中包含了免费的网络连接！好耶！只不过，它是由房东的公寓里的 WiFi 提供的，哇哦……\n说实话，它的效果还不错……吧？好吧，我承认它不尽如人意，并且不知道是哪里的问题。路由器明明就在墙的另一边，但我们的信号就是很不稳定，经常会自动断开连接。在家的时候，我们的 WiFi 路由器的信号能够穿过层层墙壁和地板。事实上，它所覆盖的区域比我们居住的 600 平方英尺（大约 55 平方米）的公寓还要大。\n在这种情况下，一个优秀的技术人员会怎么做呢？既然想知道为什么，当然是开始排查咯！\n幸运的是，我们在搬家之前并没有变卖掉树莓派 Zero W。它是如此小巧便携! 我当然就把它一起带来了。我有一个机智的想法：通过树莓派和它内置的 WiFi 适配器，使用 Go 语言编写一个小程序来测量并显示从路由器收到的 WiFi 信号。我打算先简单快速地把它实现出来，以后再去考虑优化。真是麻烦！我现在只想知道这个 WiFi 是怎么回事！\n谷歌搜索了一番后，我发现了一个比较有用的 Go 软件包 mdlayher/wifi ，它专门用于 WiFi 相关操作，听起来很有希望！\n获取 WiFi 接口的信息 我的计划是查询 WiFi 接口的统计数据并返回信号强度，所以我需要先找到设备上的接口。幸运的是，mdlayher/wifi 包有一个查询它们的方法，所以我可以创建一个 main.go 来实现它，具体代码如下：\npackage main import ( \"fmt\" \"github.com/mdlayher/wifi\" ) func main() { c, err := wifi.New() defer c.Close() if err != nil { panic(err) } interfaces, err := c.Interfaces() for _, x := range interfaces { fmt.Printf(\"%+v\\n\", x) } } 让我们来看看上面的代码都做了什么吧！首先是导入依赖包，导入后，我就可以使用 mdlayher/wifi 模块就在 main 函数中创建一个新的客户端（类型为 *Client）。接下来，只需要调用这个新的客户端（变量名为 c）的 c.Interfaces() 方法就可以获得系统中的接口列表。接着，我就可以遍历包含接口指针的切片（变长数组），然后打印出它们的具体信息。\n注意到 %+v 中有一个 + 了吗？它意味着程序会详细输出 *Interface 结构体中的属性名，这将有助于我标识出我看到的东西，而不用去查阅文档。\n运行上面的代码后，我得到了机器上的 WiFi 接口列表：\n\u0026{Index:0 Name: HardwareAddr:5c:5f:67:f3:0a:a7 PHY:0 Device:3 Type:P2P device Frequency:0} \u0026{Index:3 Name:wlp2s0 HardwareAddr:5c:5f:67:f3:0a:a7 PHY:0 Device:1 Type:station Frequency:2412} 注意，两行输出中的 MAC 地址（HardwareAddr）是相同的，这意味着它们是同一个物理硬件。你也可以通过 PHY: 0 来确认。查阅 Go 的 wifi 模块文档 ，PHY 指的就是接口所属的物理设备。\n第一个接口没有名字，类型是 TYPE: P2P。第二个接口名为 wpl2s0，类型是 TYPE: Station。wifi 模块的文档列出了 不同类型的接口 ，以及它们的用途。根据文档，P2P（点对点传输） 类型表示“该接口属于点对点客户端网络中的一个设备”。我认为这个接口的用途是 WiFi 直连 ，这是一个允许两个 WiFi 设备在没有中间接入点的情况下直接连接的标准。\nStation（基站）类型表示“该接口是具有控制接入点controlling access point的客户端设备管理的基本服务集basic service set（BSS）的一部分”。这是大众熟悉的无线设备标准功能：作为一个客户端来连接到网络接入点。这是测试 WiFi 质量的重要接口。\n利用接口获取基站信息 利用该信息，我可以修改遍历接口的代码来获取所需信息：\nfor _, x := range interfaces { if x.Type == wifi.InterfaceTypeStation { // c.StationInfo(x) returns a slice of all  // the staton information about the interface  info, err := c.StationInfo(x) if err != nil { fmt.Printf(\"Station err: %s\\n\", err) } for _, x := range info { fmt.Printf(\"%+v\\n\", x) } } } 首先，这段程序检查了 x.Type（接口类型）是否为 wifi.InterfaceTypeStation，它是一个基站接口（也是本练习中唯一涉及到的类型）。不幸的是名字出现了冲突，这个接口“类型”并不是 Golang 中的“类型”。事实上，我在这里使用了一个叫做 interfaceType 的 Go 类型来代表接口类型。呼，我花了一分钟才弄明白！\n然后，假设接口的类型正确，我们就可以调用 c.StationInfo(x) 来检索基站信息，StationInfo() 方法可以获取到关于这个接口 x 的信息。\n这将返回一个包含 *StationInfo 指针的切片。我不大确定这里为什么要用切片，或许是因为接口可能返回多个 StationInfo？不管怎么样，我都可以遍历这个切片，然后使用之前提到的 +%v 技巧格式化打印出 StationInfo 结构的属性名和属性值。\n运行上面的程序后，我得到了下面的输出：\n\u0026{HardwareAddr:70:5a:9e:71:2e:d4 Connected:17m10s Inactive:1.579s ReceivedBytes:2458563 TransmittedBytes:1295562 ReceivedPackets:6355 TransmittedPackets:6135 ReceiveBitrate:2000000 TransmitBitrate:43300000 Signal:-79 TransmitRetries:2306 TransmitFailed:4 BeaconLoss:2} 我感兴趣的是 Signal（信号）部分，可能还有 TransmitFailed（传输失败）和 BeaconLoss（信标丢失）部分。信号强度是以 dBm（分贝-毫瓦decibel-milliwatts）为单位来报告的。\n简短科普：如何读懂 WiFi dBm 根据 MetaGeek 的说法：\n -30 最佳，但它既不现实也没有必要 -67 非常好，它适用于需要可靠数据包传输的应用，例如流媒体 -70 还不错，它是实现可靠数据包传输的底线，适用于电子邮件和网页浏览 -80 很差，只是基本连接，数据包传输不可靠 -90 不可用，接近“背景噪声noise floor”  注意：dBm 是对数尺度，-60 比 -30 要低 1000 倍。\n使它成为一个真的“扫描器” 所以，看着上面输出显示的我的信号：-79。哇哦，感觉不大好呢。不过单看这个结果并没有太大帮助，它只能提供某个时间点的参考，只对 WiFi 网络适配器在特定物理空间的某一瞬间有效。一个连续的读数会更有用，借助于它，我们观察到信号随着树莓派的移动而变化。我可以再次修改 main 函数来实现这一点。\nvar i *wifi.Interface for _, x := range interfaces { if x.Type == wifi.InterfaceTypeStation { // Loop through the interfaces, and assign the station  // to var x  // We could hardcode the station by name, or index,  // or hardwareaddr, but this is more portable, if less efficient  i = x break } } for { // c.StationInfo(x) returns a slice of all  // the staton information about the interface  info, err := c.StationInfo(i) if err != nil { fmt.Printf(\"Station err: %s\\n\", err) } for _, x := range info { fmt.Printf(\"Signal: %d\\n\", x.Signal) } time.Sleep(time.Second) } 首先，我命名了一个 wifi.Interface 类型的变量 i。因为它在循环的范围外，所以我可以用它来存储接口信息。循环内创建的任何变量在该循环的范围外都是不可访问的。\n然后，我可以把这个循环一分为二。第一个遍历了 c.Interfaces() 返回的接口切片，如果元素是一个 Station 类型，它就将其存储在先前创建的变量 i 中，并跳出循环。\n第二个循环是一个死循环，它将不断地运行，直到我按下 Ctrl + C 来结束程序。和之前一样，这个循环内部获取接口信息、检索基站信息，并打印出信号信息。然后它会休眠一秒钟，再次运行，反复打印信号信息，直到我退出为止。\n运行上面的程序后，我得到了下面的输出：\n[chris@marvin wifi-monitor]$ go run main.go Signal: -81 Signal: -81 Signal: -79 Signal: -81 哇哦，感觉不妙。\n绘制公寓信号分布图 不管怎么说，知道这些信息总比不知道要好。让树莓派连接上显示器或者电子墨水屏，并接上电源，我就可以让它在公寓里移动，并绘制出信号死角的位置。\n剧透一下：由于房东的接入点在隔壁的公寓里，对我来说最大的死角是以公寓厨房的冰箱为顶点的一个圆锥体形状区域……这个冰箱与房东的公寓靠着一堵墙！\n我想如果用《龙与地下城》里的黑话来说，它就是一个“沉默之锥Cone of Silence”。或者至少是一个“糟糕的网络连接之锥Cone of Poor Internet”。\n总之，这段代码可以直接在树莓派上运行 go build -o wifi_scanner 来编译，得到的二进制文件 wifi_scanner 可以运行在其他同样的 ARM 设备上。另外，它也可以在常规系统上用正确的 ARM 设备库进行编译。\n后语 祝你扫描愉快！希望你的 WiFi 路由器不在你的冰箱后面！你可以在 我的 GitHub 存储库 中找到这个项目所用的代码。\n  本文使用 CC BY-SA 4.0 国际协议 进行许可，欢迎 遵照协议规定 转载。\n链接：https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/ 作者：Chris Collins / 译者：六开箱 原文：Troubleshoot WiFi problems with Go and a Raspberry Pi 首发：使用 Go 和树莓派排查 WiFi 问题 @ Linux 中国  ","wordCount":"3022","inLanguage":"zh","datePublished":"2022-05-08T08:50:37+08:00","dateModified":"2022-05-08T08:50:37+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>使用 Go 和树莓派排查 WiFi 问题</h1><div class=post-meta><span title="2022-05-08 08:50:37 +0800 CST">2022 年 5 月 8 日 08:50</span>&nbsp;·&nbsp;3022 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e8%8e%b7%e5%8f%96-wifi-%e6%8e%a5%e5%8f%a3%e7%9a%84%e4%bf%a1%e6%81%af aria-label="获取 WiFi 接口的信息">获取 WiFi 接口的信息</a></li><li><a href=#%e5%88%a9%e7%94%a8%e6%8e%a5%e5%8f%a3%e8%8e%b7%e5%8f%96%e5%9f%ba%e7%ab%99%e4%bf%a1%e6%81%af aria-label=利用接口获取基站信息>利用接口获取基站信息</a><ul><li><a href=#%e7%ae%80%e7%9f%ad%e7%a7%91%e6%99%ae%e5%a6%82%e4%bd%95%e8%af%bb%e6%87%82-wifi-dbm aria-label="简短科普：如何读懂 WiFi dBm">简短科普：如何读懂 WiFi dBm</a></li></ul></li><li><a href=#%e4%bd%bf%e5%ae%83%e6%88%90%e4%b8%ba%e4%b8%80%e4%b8%aa%e7%9c%9f%e7%9a%84%e6%89%ab%e6%8f%8f%e5%99%a8 aria-label=使它成为一个真的“扫描器”>使它成为一个真的“扫描器”</a></li><li><a href=#%e7%bb%98%e5%88%b6%e5%85%ac%e5%af%93%e4%bf%a1%e5%8f%b7%e5%88%86%e5%b8%83%e5%9b%be aria-label=绘制公寓信号分布图>绘制公寓信号分布图</a></li><li><a href=#%e5%90%8e%e8%af%ad aria-label=后语>后语</a></li></ul></div></details></div><div class=post-content><blockquote><p>实现一个 WiFi 扫描器玩玩～</p></blockquote><p><img loading=lazy src=https://img.linux.net.cn/data/attachment/album/202205/08/085020czfsvsfpdg0usuph.jpg alt></p><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>去年夏天，我和妻子变卖了家产，带着我们的两只狗移居了夏威夷。这里有美丽的阳光、温暖的沙滩、凉爽的冲浪等你能想到的一切。我们同样遇到了一些意料之外的事：WiFi 问题。</p><p>不过，这不是夏威夷的问题，而是我们租住公寓的问题。我们住在一个单身公寓里，与房东的公寓仅一墙之隔。我们的租房协议中包含了免费的网络连接！好耶！只不过，它是由房东的公寓里的 WiFi 提供的，哇哦……</p><p>说实话，它的效果还不错……吧？好吧，我承认它不尽如人意，并且不知道是哪里的问题。路由器明明就在墙的另一边，但我们的信号就是很不稳定，经常会自动断开连接。在家的时候，我们的 WiFi 路由器的信号能够穿过层层墙壁和地板。事实上，它所覆盖的区域比我们居住的 600 平方英尺（大约 55 平方米）的公寓还要大。</p><p>在这种情况下，一个优秀的技术人员会怎么做呢？既然想知道为什么，当然是开始排查咯！</p><p>幸运的是，我们在搬家之前并没有变卖掉树莓派 Zero W。它是如此小巧便携! 我当然就把它一起带来了。我有一个机智的想法：通过树莓派和它内置的 WiFi 适配器，使用 Go 语言编写一个小程序来测量并显示从路由器收到的 WiFi 信号。我打算先简单快速地把它实现出来，以后再去考虑优化。真是麻烦！我现在只想知道这个 WiFi 是怎么回事！</p><p>谷歌搜索了一番后，我发现了一个比较有用的 Go 软件包 <a href=https://github.com/mdlayher/wifi target=_blank rel="noopener noreferrer">mdlayher/wifi</a>
，它专门用于 WiFi 相关操作，听起来很有希望！</p><h2 id=获取-wifi-接口的信息>获取 WiFi 接口的信息<a hidden class=anchor aria-hidden=true href=#获取-wifi-接口的信息>#</a></h2><p>我的计划是查询 WiFi 接口的统计数据并返回信号强度，所以我需要先找到设备上的接口。幸运的是，<code>mdlayher/wifi</code> 包有一个查询它们的方法，所以我可以创建一个 <code>main.go</code> 来实现它，具体代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/mdlayher/wifi&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>wifi</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>interfaces</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Interfaces</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>interfaces</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%+v\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>让我们来看看上面的代码都做了什么吧！首先是导入依赖包，导入后，我就可以使用 <code>mdlayher/wifi</code> 模块就在 <code>main</code> 函数中创建一个新的客户端（类型为 <code>*Client</code>）。接下来，只需要调用这个新的客户端（变量名为 <code>c</code>）的 <code>c.Interfaces()</code> 方法就可以获得系统中的接口列表。接着，我就可以遍历包含接口指针的切片（变长数组），然后打印出它们的具体信息。</p><p>注意到 <code>%+v</code> 中有一个 <code>+</code> 了吗？它意味着程序会详细输出 <code>*Interface</code> 结构体中的属性名，这将有助于我标识出我看到的东西，而不用去查阅文档。</p><p>运行上面的代码后，我得到了机器上的 WiFi 接口列表：</p><pre tabindex=0><code>&amp;{Index:0 Name: HardwareAddr:5c:5f:67:f3:0a:a7 PHY:0 Device:3 Type:P2P device Frequency:0}
&amp;{Index:3 Name:wlp2s0 HardwareAddr:5c:5f:67:f3:0a:a7 PHY:0 Device:1 Type:station Frequency:2412}
</code></pre><p>注意，两行输出中的 MAC 地址（<code>HardwareAddr</code>）是相同的，这意味着它们是同一个物理硬件。你也可以通过 <code>PHY: 0</code> 来确认。查阅 Go 的 <a href=https://godoc.org/github.com/mdlayher/wifi#Interface target=_blank rel="noopener noreferrer">wifi 模块文档</a>
，<code>PHY</code> 指的就是接口所属的物理设备。</p><p>第一个接口没有名字，类型是 <code>TYPE: P2P</code>。第二个接口名为 <code>wpl2s0</code>，类型是 <code>TYPE: Station</code>。<code>wifi</code> 模块的文档列出了 <a href=https://godoc.org/github.com/mdlayher/wifi#InterfaceType target=_blank rel="noopener noreferrer">不同类型的接口</a>
，以及它们的用途。根据文档，<code>P2P</code>（点对点传输） 类型表示“该接口属于点对点客户端网络中的一个设备”。我认为这个接口的用途是 <a href=https://en.wikipedia.org/wiki/Wi-Fi_Direct target=_blank rel="noopener noreferrer">WiFi 直连</a>
，这是一个允许两个 WiFi 设备在没有中间接入点的情况下直接连接的标准。</p><p><code>Station</code>（基站）类型表示“该接口是具有<ruby>控制接入点<rt>controlling access point</rt></ruby>的客户端设备管理的<ruby>基本服务集<rt>basic service set</rt></ruby>（BSS）的一部分”。这是大众熟悉的无线设备标准功能：作为一个客户端来连接到网络接入点。这是测试 WiFi 质量的重要接口。</p><h2 id=利用接口获取基站信息>利用接口获取基站信息<a hidden class=anchor aria-hidden=true href=#利用接口获取基站信息>#</a></h2><p>利用该信息，我可以修改遍历接口的代码来获取所需信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>interfaces</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>x</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>wifi</span><span class=p>.</span><span class=nx>InterfaceTypeStation</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// c.StationInfo(x) returns a slice of all
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// the staton information about the interface
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>info</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>StationInfo</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Station err: %s\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>info</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%+v\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先，这段程序检查了 <code>x.Type</code>（接口类型）是否为 <code>wifi.InterfaceTypeStation</code>，它是一个基站接口（也是本练习中唯一涉及到的类型）。不幸的是名字出现了冲突，这个接口“类型”并不是 Golang 中的“类型”。事实上，我在这里使用了一个叫做 <code>interfaceType</code> 的 Go 类型来代表接口类型。呼，我花了一分钟才弄明白！</p><p>然后，假设接口的类型正确，我们就可以调用 <code>c.StationInfo(x)</code> 来检索基站信息，<code>StationInfo()</code> 方法可以获取到关于这个接口 <code>x</code> 的信息。</p><p>这将返回一个包含 <code>*StationInfo</code> 指针的切片。我不大确定这里为什么要用切片，或许是因为接口可能返回多个 <code>StationInfo</code>？不管怎么样，我都可以遍历这个切片，然后使用之前提到的 <code>+%v</code> 技巧格式化打印出 <code>StationInfo</code> 结构的属性名和属性值。</p><p>运行上面的程序后，我得到了下面的输出：</p><pre tabindex=0><code>&amp;{HardwareAddr:70:5a:9e:71:2e:d4 Connected:17m10s Inactive:1.579s ReceivedBytes:2458563 TransmittedBytes:1295562 ReceivedPackets:6355 TransmittedPackets:6135 ReceiveBitrate:2000000 TransmitBitrate:43300000 Signal:-79 TransmitRetries:2306 TransmitFailed:4 BeaconLoss:2}
</code></pre><p>我感兴趣的是 <code>Signal</code>（信号）部分，可能还有 <code>TransmitFailed</code>（传输失败）和 <code>BeaconLoss</code>（信标丢失）部分。信号强度是以 dBm（<ruby>分贝-毫瓦<rt>decibel-milliwatts</rt><ruby>）为单位来报告的。</p><h3 id=简短科普如何读懂-wifi-dbm>简短科普：如何读懂 WiFi dBm<a hidden class=anchor aria-hidden=true href=#简短科普如何读懂-wifi-dbm>#</a></h3><p>根据 <a href=https://www.metageek.com/training/resources/wifi-signal-strength-basics.html target=_blank rel="noopener noreferrer">MetaGeek</a>
的说法：</p><ul><li>-30 最佳，但它既不现实也没有必要</li><li>-67 非常好，它适用于需要可靠数据包传输的应用，例如流媒体</li><li>-70 还不错，它是实现可靠数据包传输的底线，适用于电子邮件和网页浏览</li><li>-80 很差，只是基本连接，数据包传输不可靠</li><li>-90 不可用，接近“<ruby>背景噪声<rt>noise floor</rt></ruby>”</li></ul><p><em>注意：dBm 是对数尺度，-60 比 -30 要低 1000 倍。</em></p><h2 id=使它成为一个真的扫描器>使它成为一个真的“扫描器”<a hidden class=anchor aria-hidden=true href=#使它成为一个真的扫描器>#</a></h2><p>所以，看着上面输出显示的我的信号：-79。哇哦，感觉不大好呢。不过单看这个结果并没有太大帮助，它只能提供某个时间点的参考，只对 WiFi 网络适配器在特定物理空间的某一瞬间有效。一个连续的读数会更有用，借助于它，我们观察到信号随着树莓派的移动而变化。我可以再次修改 <code>main</code> 函数来实现这一点。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>i</span> <span class=o>*</span><span class=nx>wifi</span><span class=p>.</span><span class=nx>Interface</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>interfaces</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>x</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>wifi</span><span class=p>.</span><span class=nx>InterfaceTypeStation</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Loop through the interfaces, and assign the station
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// to var x
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// We could hardcode the station by name, or index,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// or hardwareaddr, but this is more portable, if less efficient
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>i</span> <span class=p>=</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// c.StationInfo(x) returns a slice of all
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the staton information about the interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>info</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>StationInfo</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Station err: %s\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>info</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Signal: %d\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>.</span><span class=nx>Signal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先，我命名了一个 <code>wifi.Interface</code> 类型的变量 <code>i</code>。因为它在循环的范围外，所以我可以用它来存储接口信息。循环内创建的任何变量在该循环的范围外都是不可访问的。</p><p>然后，我可以把这个循环一分为二。第一个遍历了 <code>c.Interfaces()</code> 返回的接口切片，如果元素是一个 <code>Station</code> 类型，它就将其存储在先前创建的变量 <code>i</code> 中，并跳出循环。</p><p>第二个循环是一个死循环，它将不断地运行，直到我按下 <code>Ctrl + C</code> 来结束程序。和之前一样，这个循环内部获取接口信息、检索基站信息，并打印出信号信息。然后它会休眠一秒钟，再次运行，反复打印信号信息，直到我退出为止。</p><p>运行上面的程序后，我得到了下面的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>chris@marvin wifi-monitor<span class=o>]</span>$ go run main.go
</span></span><span class=line><span class=cl>Signal: -81
</span></span><span class=line><span class=cl>Signal: -81
</span></span><span class=line><span class=cl>Signal: -79
</span></span><span class=line><span class=cl>Signal: -81
</span></span></code></pre></div><p>哇哦，感觉不妙。</p><h2 id=绘制公寓信号分布图>绘制公寓信号分布图<a hidden class=anchor aria-hidden=true href=#绘制公寓信号分布图>#</a></h2><p>不管怎么说，知道这些信息总比不知道要好。让树莓派连接上显示器或者电子墨水屏，并接上电源，我就可以让它在公寓里移动，并绘制出信号死角的位置。</p><p>剧透一下：由于房东的接入点在隔壁的公寓里，对我来说最大的死角是以公寓厨房的冰箱为顶点的一个圆锥体形状区域……这个冰箱与房东的公寓靠着一堵墙！</p><p>我想如果用《龙与地下城》里的黑话来说，它就是一个“<ruby>沉默之锥<rt>Cone of Silence</rt></ruby>”。或者至少是一个“<ruby>糟糕的网络连接之锥<rt>Cone of Poor Internet</rt></ruby>”。</p><p>总之，这段代码可以直接在树莓派上运行 <code>go build -o wifi_scanner</code> 来编译，得到的二进制文件 <code>wifi_scanner</code> 可以运行在其他同样的 ARM 设备上。另外，它也可以在常规系统上用正确的 ARM 设备库进行编译。</p><h2 id=后语>后语<a hidden class=anchor aria-hidden=true href=#后语>#</a></h2><p>祝你扫描愉快！希望你的 WiFi 路由器不在你的冰箱后面！你可以在 <a href=https://github.com/clcollins/goPiWiFi target=_blank rel="noopener noreferrer">我的 GitHub 存储库</a>
中找到这个项目所用的代码。</p><hr><blockquote><p>本文使用 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh target=_blank rel="noopener noreferrer">CC BY-SA 4.0 国际协议</a>
进行许可，欢迎 <strong>遵照协议规定</strong> 转载。<br>链接：<a href=https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/troubleshoot-wifi-go-raspberry-pi/</a><br>作者：<a href=https://opensource.com/users/clcollins target=_blank rel="noopener noreferrer">Chris Collins</a>
/ 译者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>原文：<a href=https://opensource.com/article/21/3/troubleshoot-wifi-go-raspberry-pi target=_blank rel="noopener noreferrer">Troubleshoot WiFi problems with Go and a Raspberry Pi</a><br>首发：<a href=https://linux.cn/article-14560-1.html target=_blank rel="noopener noreferrer">使用 Go 和树莓派排查 WiFi 问题</a>
@ <a href=https://linux.cn/ target=_blank rel="noopener noreferrer">Linux 中国</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/%E8%AF%91%E6%96%87/>译文</a></li><li><a href=https://lkxed.github.io/tags/%E6%8A%80%E6%9C%AF/>技术</a></li><li><a href=https://lkxed.github.io/tags/%E7%BD%91%E7%BB%9C/>网络</a></li><li><a href=https://lkxed.github.io/tags/go/>Go</a></li><li><a href=https://lkxed.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/>树莓派</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/product-management-open-source/><span class=title>« 上一页</span><br><span>我如何通过开源来发展我的产品经理职业</span></a>
<a class=next href=https://lkxed.github.io/posts/elementary-os-7-announcement/><span class=title>下一页 »</span><br><span>elementary OS 7 公布了它的代号</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>