<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis 持久化：RDB 与 AOF 的优缺点｜六开箱</title><meta name=keywords content="Redis,持久化,RDB,AOF"><meta name=description content="Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/redis-persistence-pros-cons/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="Redis 持久化：RDB 与 AOF 的优缺点"><meta property="og:description" content="Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/redis-persistence-pros-cons/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-24T13:35:25+08:00"><meta property="article:modified_time" content="2022-04-24T13:35:25+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 持久化：RDB 与 AOF 的优缺点"><meta name=twitter:description content="Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis 持久化：RDB 与 AOF 的优缺点","item":"https://lkxed.github.io/posts/redis-persistence-pros-cons/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis 持久化：RDB 与 AOF 的优缺点","name":"Redis 持久化：RDB 与 AOF 的优缺点","description":"Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！","keywords":["Redis","持久化","RDB","AOF"],"articleBody":" Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！\n 前言 持久化就是指把数据写入到一个持久的存储设备（例如固态硬盘）中。\nRedis 提供了一系列持久化选项：\n RDB（Redis Database）：经过指定的时间间隔，自动生成该时间点的数据集快照。 AOF（Append Only File）：记录每一个 server 收到的写操作到一个日志文件中。每当 server 重新启动时，它都会重放这些操作来恢复原始数据集。写操作使用 Redis 协议的格式保存，仅追加文件。当这个日志文件变得太大时，server 可以在后台重写它。 No persistence：不配置持久化，数据仅在 server 运行时存在于内存中，server 停止运行后数据消失。 RDB + AOF：可以在同一个 server 实例中，同时使用 AOF 和 RDB 这两种持久化方式。需要注意的是，当 server 重新启动时，它将使用 AOF 文件来恢复原始数据集，因为它是最完整的。  然而，最重要的是理解 RDB 和 AOF 这两种持久化方式各有什么优缺点。\nRDB 优点  RDB 把 server 中的数据保存在一个紧凑的文件中，它很适合用于备份。例如，你可能会想要每隔一个小时都备份一次过去 24 小时的数据，或者每隔一天备份一次过去 30 天的数据。当灾难来临时，RDB 使你可以很轻松地恢复不同版本的数据集。 RDB 非常适合灾备恢复，它是一个单文件，可以在相距很远的数据中心之间转移。 RDB 几乎不会影响 server 的性能，因为 server 进程唯一需要做的事就是 fork 一个子进程，然后让子进程完成剩下的所有工作，server 进程不会参与任何的磁盘 I/O。 如果重启时要恢复一个很大的数据集，那么与 AOF 相比，RDB 会快很多。 复制时，如果出现重启或者失败的情况，RDB 支持重新同步部分的数据。  RDB 缺点  如果你想要追求最少的数据损失（比方说在一次停电后），那么 RDB 不适合你。你可以设置不同的保存点（比如每隔 5 分钟 或者每写入 100 次），你可以同时设置多个保存点。然而，一般都是设置在 5 分钟以上，因此如果 server 没有正常停止的话，你要做好丢失最近几分钟数据的准备。 RDB 需要经常调用 fork() 生成子进程来进行持久化工作。然而，如果需要持久化的数据集很大的话，执行 fork() 需要耗费大量的时间。如果数据集非常大，并且服务器的 CPU 不大给力的话，这还可能会导致 server 在数个毫秒甚至一秒内暂停接受 client 请求。AOF 也需要 fork()，但是要不频繁一些，而且它还支持让你在不损失数据的持久型的前提下，修改重写日志的频率。  AOF 优点  使用 AOF 可以让 server 的持久化程度更高，因为它支持不同的 fsync 策略，比如说：不用 fsync，每秒钟执行一次 fsync，每次查询执行一次 fsync 等。默认的策略是每秒钟执行一次 fsync，性能仍然很棒。fsync 在后台线程执行的，在不执行 fsync 时，主线程会尽全力去执行写操作。这样一来，你最多丢失一秒钟的数据而已。 AOF 日志文件是一个仅追加的文件，所以它不需要执行查找，断电时也没有崩溃问题。即使最后一条命令只写了一半（由于磁盘写满了或其他原因），redis-check-aof 工具也可以轻松修复这个 AOF 日志文件。 当 AOF 变得太大了时，server 可以自动在后台重写它。重写操作是非常安全的，因为在 server 持续追加命令到旧文件时，新的文件会被同时创建。server 会对这个新的文件进行一些设置，一旦完成，server 就会开始追加命令到新的文件中。 AOF 一条条地记录了所有的操作，记录的格式是非常容易理解和解析的。你甚至可以很轻松地导出一个 AOF 文件。比如说，即使你意外地使用 FLUSHALL 命令覆盖了所有的数据，只要这时候没有进行 AOF 重写，你都可以恢复你的数据。你只需要停止 server，删除最近的一条命令，然后重启 server 就好了。  AOF 缺点  对于同一个数据集，AOF 文件通常会比 RDB 文件要占用更多的空间。 取决于不同的 fsync 策略，AOF 可能会比 RDB 要慢。通常来说，每秒钟执行一次 fsync，性能仍然很棒；禁用 fsync 后，即使在高负载下，性能也应该和 RDB 差不多。不过，RDB 仍然在能够保证在写负载很大的情况下，提供（较小）最大延时的保证，这是 AOF 做不到的。  对于 Redis 7.0 以下版本，AOF 还有下面这几个缺点：\n 在一次重写中，如果 server 同时接受了写操作，那么 AOF 会占用大量的内存（因为这些写操作会缓存在内存里，最后才会写入到新的 AOF 文件中）。 所有在执行重写时到达 server 的写操作，都会被重复写入一次磁盘。 在重写结束时，server 会把写入操作追加到新的 AOF 文件中，在这期间，server 可能会停止写入内存数据。  后语 下一篇文章，我将介绍如何选用 Redis 的这两种持久化方式（RDB 和 AOF）。保持关注喔！\n参考资料 Redis Documentation - Redis persistence   转载须知：本文遵循 CC BY-SA 4.0 许可协议 作者：六开箱 链接：https://lkxed.github.io/posts/redis-persistence-pros-cons/  ","wordCount":"1909","inLanguage":"zh","datePublished":"2022-04-24T13:35:25+08:00","dateModified":"2022-04-24T13:35:25+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/redis-persistence-pros-cons/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis 持久化：RDB 与 AOF 的优缺点</h1><div class=post-meta><span title="2022-04-24 13:35:25 +0800 CST">2022 年 4 月 24 日</span>&nbsp;·&nbsp;1909 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#rdb-%e4%bc%98%e7%82%b9 aria-label="RDB 优点">RDB 优点</a></li><li><a href=#rdb-%e7%bc%ba%e7%82%b9 aria-label="RDB 缺点">RDB 缺点</a></li><li><a href=#aof-%e4%bc%98%e7%82%b9 aria-label="AOF 优点">AOF 优点</a></li><li><a href=#aof-%e7%bc%ba%e7%82%b9 aria-label="AOF 缺点">AOF 缺点</a></li><li><a href=#%e5%90%8e%e8%af%ad aria-label=后语>后语</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><blockquote><p>Redis 往磁盘里写入数据（持久化）的方式，包括了“仅追加文件”（AOF）和“快照”（RDB）两种，让我们一起来看看它们的优点与缺点吧！</p></blockquote><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>持久化就是指把数据写入到一个持久的存储设备（例如固态硬盘）中。</p><p>Redis 提供了一系列持久化选项：</p><ul><li><strong>RDB</strong>（Redis Database）：经过指定的时间间隔，自动生成该时间点的数据集快照。</li><li><strong>AOF</strong>（Append Only File）：记录每一个 server 收到的写操作到一个日志文件中。每当 server 重新启动时，它都会重放这些操作来恢复原始数据集。写操作使用 Redis 协议的格式保存，仅追加文件。当这个日志文件变得太大时，server 可以在后台重写它。</li><li><strong>No persistence</strong>：不配置持久化，数据仅在 server 运行时存在于内存中，server 停止运行后数据消失。</li><li><strong>RDB + AOF</strong>：可以在同一个 server 实例中，同时使用 AOF 和 RDB 这两种持久化方式。需要注意的是，当 server 重新启动时，它将使用 AOF 文件来恢复原始数据集，因为它是最完整的。</li></ul><p>然而，最重要的是理解 RDB 和 AOF 这两种持久化方式各有什么优缺点。</p><h2 id=rdb-优点>RDB 优点<a hidden class=anchor aria-hidden=true href=#rdb-优点>#</a></h2><ul><li>RDB 把 server 中的数据保存在一个紧凑的文件中，它很适合用于备份。例如，你可能会想要每隔一个小时都备份一次过去 24 小时的数据，或者每隔一天备份一次过去 30 天的数据。当灾难来临时，RDB 使你可以很轻松地恢复不同版本的数据集。</li><li>RDB 非常适合灾备恢复，它是一个单文件，可以在相距很远的数据中心之间转移。</li><li>RDB 几乎不会影响 server 的性能，因为 server 进程唯一需要做的事就是 fork 一个子进程，然后让子进程完成剩下的所有工作，server 进程不会参与任何的磁盘 I/O。</li><li>如果重启时要恢复一个很大的数据集，那么与 AOF 相比，RDB 会快很多。</li><li>复制时，如果出现重启或者失败的情况，RDB 支持重新同步部分的数据。</li></ul><h2 id=rdb-缺点>RDB 缺点<a hidden class=anchor aria-hidden=true href=#rdb-缺点>#</a></h2><ul><li>如果你想要追求最少的数据损失（比方说在一次停电后），那么 RDB 不适合你。你可以设置不同的保存点（比如每隔 5 分钟 或者每写入 100 次），你可以同时设置多个保存点。然而，一般都是设置在 5 分钟以上，因此如果 server 没有正常停止的话，你要做好丢失最近几分钟数据的准备。</li><li>RDB 需要经常调用 <code>fork()</code> 生成子进程来进行持久化工作。然而，如果需要持久化的数据集很大的话，执行 <code>fork()</code> 需要耗费大量的时间。如果数据集非常大，并且服务器的 CPU 不大给力的话，这还可能会导致 server 在数个毫秒甚至一秒内暂停接受 client 请求。AOF 也需要 <code>fork()</code>，但是要不频繁一些，而且它还支持让你在不损失数据的持久型的前提下，修改重写日志的频率。</li></ul><h2 id=aof-优点>AOF 优点<a hidden class=anchor aria-hidden=true href=#aof-优点>#</a></h2><ul><li>使用 AOF 可以让 server 的持久化程度更高，因为它支持不同的 fsync 策略，比如说：不用 fsync，每秒钟执行一次 fsync，每次查询执行一次 fsync 等。默认的策略是每秒钟执行一次 fsync，性能仍然很棒。fsync 在后台线程执行的，在不执行 fsync 时，主线程会尽全力去执行写操作。这样一来，你最多丢失一秒钟的数据而已。</li><li>AOF 日志文件是一个仅追加的文件，所以它不需要执行查找，断电时也没有崩溃问题。即使最后一条命令只写了一半（由于磁盘写满了或其他原因），<code>redis-check-aof</code> 工具也可以轻松修复这个 AOF 日志文件。</li><li>当 AOF 变得太大了时，server 可以自动在后台重写它。重写操作是非常安全的，因为在 server 持续追加命令到旧文件时，新的文件会被同时创建。server 会对这个新的文件进行一些设置，一旦完成，server 就会开始追加命令到新的文件中。</li><li>AOF 一条条地记录了所有的操作，记录的格式是非常容易理解和解析的。你甚至可以很轻松地导出一个 AOF 文件。比如说，即使你意外地使用 <code>FLUSHALL</code> 命令覆盖了所有的数据，只要这时候没有进行 AOF 重写，你都可以恢复你的数据。你只需要停止 server，删除最近的一条命令，然后重启 server 就好了。</li></ul><h2 id=aof-缺点>AOF 缺点<a hidden class=anchor aria-hidden=true href=#aof-缺点>#</a></h2><ul><li>对于同一个数据集，AOF 文件通常会比 RDB 文件要占用更多的空间。</li><li>取决于不同的 fsync 策略，AOF 可能会比 RDB 要慢。通常来说，每秒钟执行一次 fsync，性能仍然很棒；禁用 fsync 后，即使在高负载下，性能也应该和 RDB 差不多。不过，RDB 仍然在能够保证在写负载很大的情况下，提供（较小）最大延时的保证，这是 AOF 做不到的。</li></ul><p>对于 Redis 7.0 以下版本，AOF 还有下面这几个缺点：</p><ul><li>在一次重写中，如果 server 同时接受了写操作，那么 AOF 会占用大量的内存（因为这些写操作会缓存在内存里，最后才会写入到新的 AOF 文件中）。</li><li>所有在执行重写时到达 server 的写操作，都会被重复写入一次磁盘。</li><li>在重写结束时，server 会把写入操作追加到新的 AOF 文件中，在这期间，server 可能会停止写入内存数据。</li></ul><h2 id=后语>后语<a hidden class=anchor aria-hidden=true href=#后语>#</a></h2><p>下一篇文章，我将介绍<strong>如何选用</strong> Redis 的这两种持久化方式（RDB 和 AOF）。保持关注喔！</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://redis.io/docs/manual/persistence/ target=_blank rel="noopener noreferrer">Redis Documentation - Redis persistence</a></p><hr><blockquote><p>转载须知：本文遵循 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh target=_blank rel="noopener noreferrer">CC BY-SA 4.0 许可协议</a><br>作者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>链接：<a href=https://lkxed.github.io/posts/redis-persistence-pros-cons/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/redis-persistence-pros-cons/</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li><li><a href=https://lkxed.github.io/tags/redis/>Redis</a></li><li><a href=https://lkxed.github.io/tags/%E7%AE%80%E4%BB%8B/>简介</a></li></ul><nav class=paginav><a class=next href=https://lkxed.github.io/posts/go-string-trim/><span class=title>下一页 »</span><br><span>Go string：正确删除子串</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>