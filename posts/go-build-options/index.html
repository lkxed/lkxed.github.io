<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>我最喜欢的 Go 构建选项｜六开箱</title><meta name=keywords content="Go,build,run,选项"><meta name=description content="这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/go-build-options/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="我最喜欢的 Go 构建选项"><meta property="og:description" content="这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/go-build-options/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-30T17:21:04+08:00"><meta property="article:modified_time" content="2022-04-30T17:21:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="我最喜欢的 Go 构建选项"><meta name=twitter:description content="这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"我最喜欢的 Go 构建选项","item":"https://lkxed.github.io/posts/go-build-options/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"我最喜欢的 Go 构建选项","name":"我最喜欢的 Go 构建选项","description":"这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。","keywords":["Go","build","run","选项"],"articleBody":" 这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。\n前言 学习一门新的编程语言最令人欣慰的部分之一，就是最终运行了一个可执行文件，并获得预期的输出。当我开始学习 Go 这门编程语言时，我先是阅读一些示例程序来熟悉语法，然后是尝试写一些小的测试程序。随着时间的推移，这种方法帮助我熟悉了编译和构建程序的过程。\nGo 的构建选项提供了更好地控制构建过程的方法。它们还可以提供额外的信息，帮助把这个过程分成更小的部分。在这篇文章中，我将演示我所使用的一些选项。注意：我使用的“构建build”和“编译compile”这两个词是同一个意思。\n开始使用 Go 我使用的 Go 版本是 1.16.7。但是，这里给出的命令应该也能在最新的版本上运行。如果你没有安装 Go，你可以从 Go 官网 上下载它，并按照说明进行安装。你可以通过打开一个命令提示符，并键入下面的命令来验证你所安装的版本：\n$ go version 你应该会得到类似下面这样的输出，具体取决于你安装的版本：\ngo version go1.16.7 linux/amd64 基本的的编译和执行方法 我将从一个在屏幕上简单打印 “Hello World” 的 Go 程序示例开始，就像下面这样：\n$ cat hello.go package main import \"fmt\" func main() { fmt.Println(\"Hello World\") } 在讨论更高级的选项之前，我将解释如何编译这个 Go 示例程序。我使用了 build 命令，后面跟着 Go 程序的源文件名，本例中是 hello.go，就像下面这样：\n$ go build hello.go 如果一切工作正常，你应该看到在你的当前目录下创建了一个名为 hello 的可执行文件。你可以通过使用 file 命令验证它是 ELF 二进制可执行格式（在 Linux 平台上）。你也可以直接执行它，你会看到它输出 “Hello World”。\n$ ls hello hello.go $ file ./hello ./hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped $ ./hello Hello World Go 提供了一个方便的 run 命令，以便你只是想看看程序是否能正常工作，并获得预期的输出，而不想生成一个最终的二进制文件。请记住，即使你在当前目录中没有看到可执行文件，Go 仍然会在某个地方编译并生成可执行文件并运行它，然后把它从系统中删除。我将在本文后面的章节中解释。\n$ go run hello.go Hello World $ ls hello.go 更多细节 上面的命令就像一阵风一样，一下子就运行完了我的程序。然而，如果你想知道 Go 在编译这些程序的过程中做了什么，Go 提供了一个 -x 选项，它可以打印出 Go 为产生这个可执行文件所做的一切。\n简单看一下你就会发现，Go 在 /tmp 内创建了一个临时工作目录，并生成了可执行文件，然后把它移到了 Go 源程序所在的当前目录。\n$ go build -x hello.go WORK=/tmp/go-build1944767317 mkdir -p $WORK/b001/ \u003c\u003c snip \u003e\u003e mkdir -p $WORK/b001/exe/ cd . /usr/lib/golang/pkg/tool/linux_amd64/link -o $WORK \\ /b001/exe/a.out -importcfg $WORK/b001 \\ /importcfg.link -buildmode=exe -buildid=K26hEYzgDkqJjx2Hf-wz/\\ nDueg0kBjIygx25rYwbK/W-eJaGIOdPEWgwC6o546 \\ /K26hEYzgDkqJjx2Hf-wz -extld=gcc /root/.cache/go-build /cc \\ /cc72cb2f4fbb61229885fc434995964a7a4d6e10692a23cc0ada6707c5d3435b-d /usr/lib/golang/pkg/tool/linux_amd64/buildid -w $WORK \\ /b001/exe/a.out # internal mv $WORK/b001/exe/a.out hello rm -r $WORK/b001/ 这有助于解决在程序运行后却在当前目录下没有生成可执行文件的谜团。使用 -x 显示可执行文件确实在 /tmp 工作目录下创建并被执行了。然而，与 build 命令不同的是，可执行文件并没有移动到当前目录，这使得看起来没有可执行文件被创建。\n$ go run -x hello.go mkdir -p $WORK/b001/exe/ cd . /usr/lib/golang/pkg/tool/linux_amd64/link -o $WORK/b001 \\ /exe/hello -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=hK3wnAP20DapUDeuvAAS/E_TzkbzwXz6tM5dEC8Mx \\ /7HYBzuaDGVdaZwSMEWAa/hK3wnAP20DapUDeuvAAS -extld=gcc \\ /root/.cache/go-build/75/ \\ 7531fcf5e48444eed677bfc5cda1276a52b73c62ebac3aa99da3c4094fa57dc3-d $WORK/b001/exe/hello Hello World 模仿编译而不产生可执行文件 假设你不想编译程序并产生一个实际的二进制文件，但你确实想看到这个过程中的所有步骤。你可以通过使用 -n 这个构建选项来做到这一点，该选项会打印出通常的执行步骤，而不会实际创建二进制文件。\n$ go build -n hello.go 保存临时目录 很多工作都发生在 /tmp 工作目录中，一旦可执行文件被创建和运行，它就会被删除。但是如果你想看看哪些文件是在编译过程中创建的呢？Go 提供了一个 -work 选项，它可以在编译程序时使用。-work 选项除了运行程序外，还打印了工作目录的路径，但它并不会在这之后删除工作目录，所以你可以切换到该目录，检查在编译过程中创建的所有文件。\n$ go run -work hello.go WORK=/tmp/go-build3209320645 Hello World $ find /tmp/go-build3209320645 /tmp/go-build3209320645 /tmp/go-build3209320645/b001 /tmp/go-build3209320645/b001/importcfg.link /tmp/go-build3209320645/b001/exe /tmp/go-build3209320645/b001/exe/hello $ /tmp/go-build3209320645/b001/exe/hello Hello World 其他编译选项 如果说，你想手动编译程序，而不是使用 Go 的 build 和 run 这两个方便的命令，最后得到一个可以直接由你的操作系统（这里指 Linux）运行的可执行文件。那么，你该怎么做呢？这个过程可以分为两部分：编译和链接。你可以使用 tool 选项来看看它是如何工作的。\n首先，使用 tool compile 命令产生结果的 ar 归档文件，它包含了 .o 中间文件。接下来，对这个 hello.o 文件执行 tool link 命令，产生最终的可执行文件，然后你就可以运行它了。\n$ go tool compile hello.go $ file hello.o hello.o: current ar archive $ ar t hello.o __.PKGDEF _go_.o $ go tool link -o hello hello.o $ file hello hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped $ ./hello Hello World 如果你想进一步查看基于 hello.o 文件产生可执行文件的链接过程，你可以使用 -v 选项，它会搜索每个 Go 可执行文件中包含的 runtime.a 文件。\n$ go tool link -v -o hello hello.o HEADER = -H5 -T0x401000 -R0x1000 searching for runtime.a in /usr/lib/golang/pkg/linux_amd64/runtime.a 82052 symbols, 18774 reachable 1 package symbols, 1106 hashed symbols, 77185 non-package symbols, 3760 external symbols 81968 liveness data 交叉编译选项 现在我已经解释了 Go 程序的编译过程，接下来，我将演示 Go 如何通过在实际的 build 命令之前提供 GOOS 和 GOARCH 这两个环境变量，来允许你构建针对不同硬件架构和操作系统的可执行文件。\n这有什么用呢？举个例子，你会发现为 ARM（arch64）架构制作的可执行文件不能在英特尔（x86_64）架构上运行，而且会产生一个 Exec 格式错误。\n下面的这些选项使得生成跨平台的二进制文件变得小菜一碟：\n$ GOOS=linux GOARCH=arm64 go build hello.go $ file ./hello ./hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped $ ./hello bash: ./hello: cannot execute binary file: Exec format error $ uname -m x86_64 你可以阅读我之前的博文，以更多了解我在 使用 Go 进行交叉编译 方面的经验。\n查看底层汇编指令 源代码并不会直接转换为可执行文件，尽管它生成了一种中间汇编格式，然后最终被组装为可执行文件。在 Go 中，这被映射为一种中间汇编格式，而不是底层硬件汇编指令。\n要查看这个中间汇编格式，请在使用 build 命令时，提供 -gcflags 选项，后面跟着 -S。这个命令将会显示使用到的汇编指令：\n$ go build -gcflags=\"-S\" hello.go # command-line-arguments \"\".main STEXT size=138 args=0x0 locals=0x58 funcid=0x0 0x0000 00000 (/test/hello.go:5) TEXT \"\".main(SB), ABIInternal, $88-0 0x0000 00000 (/test/hello.go:5) MOVQ (TLS), CX 0x0009 00009 (/test/hello.go:5) CMPQ SP, 16(CX) 0x000d 00013 (/test/hello.go:5) PCDATA $0, $-2 0x000d 00013 (/test/hello.go:5) JLS 128 \u003c\u003c snip \u003e\u003e 你也可以使用 objdump -s 选项，来查看已经编译好的可执行程序的汇编指令，就像下面这样：\n$ ls hello hello.go $ go tool objdump -s main.main hello TEXT main.main(SB) /test/hello.go hello.go:5 0x4975a0 64488b0c25f8ffffff MOVQ FS:0xfffffff8, CX hello.go:5 0x4975a9 483b6110 CMPQ 0x10(CX), SP hello.go:5 0x4975ad 7671 JBE 0x497620 hello.go:5 0x4975af 4883ec58 SUBQ $0x58, SP hello.go:6 0x4975d8 4889442448 MOVQ AX, 0x48(SP) \u003c\u003c snip \u003e\u003e 分离二进制文件以减少其大小 Go 的二进制文件通常比较大。例如, 一个简单的 “Hello World” 程序将会产生一个 1.9M 大小的二进制文件。\n$ go build hello.go $ $ du -sh hello 1.9M hello $ $ file hello hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped $ 为了减少生成的二进制文件的大小，你可以分离执行过程中不需要的信息。使用 -ldflags 和 -s -w 选项可以使生成的二进制文件略微变小为 1.3M。\n$ go build -ldflags=\"-s -w\" hello.go $ $ du -sh hello 1.3M hello $ $ file hello hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped $ 总结 我希望这篇文章向你介绍了一些方便的 Go 编译选项，同时帮助了你更好地理解 Go 编译过程。关于构建过程的其他信息和其他有趣的选项，请参考 Go 命令帮助：\n$ go help build 本文使用 CC BY-SA 4.0 国际协议 进行许可，欢迎 遵照协议规定 转载。\n链接：https://lkxed.github.io/posts/go-build-options/ 作者：Gaurav Kamathe / 译者：六开箱 原文：My favorite build options for Go 首发：我最喜欢的 Go 构建选项 @ Linux 中国 ","wordCount":"2650","inLanguage":"zh","datePublished":"2022-04-30T17:21:04+08:00","dateModified":"2022-04-30T17:21:04+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/go-build-options/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>我最喜欢的 Go 构建选项</h1><div class=post-meta><span title='2022-04-30 17:21:04 +0800 CST'>2022 年 4 月 30 日 17:21</span>&nbsp;·&nbsp;2650 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8-go aria-label="开始使用 Go">开始使用 Go</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e7%9a%84%e7%bc%96%e8%af%91%e5%92%8c%e6%89%a7%e8%a1%8c%e6%96%b9%e6%b3%95 aria-label=基本的的编译和执行方法>基本的的编译和执行方法</a></li><li><a href=#%e6%9b%b4%e5%a4%9a%e7%bb%86%e8%8a%82 aria-label=更多细节>更多细节</a></li><li><a href=#%e6%a8%a1%e4%bb%bf%e7%bc%96%e8%af%91%e8%80%8c%e4%b8%8d%e4%ba%a7%e7%94%9f%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 aria-label=模仿编译而不产生可执行文件>模仿编译而不产生可执行文件</a></li><li><a href=#%e4%bf%9d%e5%ad%98%e4%b8%b4%e6%97%b6%e7%9b%ae%e5%bd%95 aria-label=保存临时目录>保存临时目录</a></li><li><a href=#%e5%85%b6%e4%bb%96%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9 aria-label=其他编译选项>其他编译选项</a></li><li><a href=#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9 aria-label=交叉编译选项>交叉编译选项</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e5%ba%95%e5%b1%82%e6%b1%87%e7%bc%96%e6%8c%87%e4%bb%a4 aria-label=查看底层汇编指令>查看底层汇编指令</a></li><li><a href=#%e5%88%86%e7%a6%bb%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6%e4%bb%a5%e5%87%8f%e5%b0%91%e5%85%b6%e5%a4%a7%e5%b0%8f aria-label=分离二进制文件以减少其大小>分离二进制文件以减少其大小</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><blockquote><p>这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。</p></blockquote><p><img loading=lazy src=https://img.linux.net.cn/data/attachment/album/202204/30/172121exam5k8vx45kzk7p.jpg alt></p><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>学习一门新的编程语言最令人欣慰的部分之一，就是最终运行了一个可执行文件，并获得预期的输出。当我开始学习 Go 这门编程语言时，我先是阅读一些示例程序来熟悉语法，然后是尝试写一些小的测试程序。随着时间的推移，这种方法帮助我熟悉了编译和构建程序的过程。</p><p>Go 的构建选项提供了更好地控制构建过程的方法。它们还可以提供额外的信息，帮助把这个过程分成更小的部分。在这篇文章中，我将演示我所使用的一些选项。注意：我使用的“<ruby>构建<rt>build</rt></ruby>”和“<ruby>编译<rt>compile</rt></ruby>”这两个词是同一个意思。</p><h2 id=开始使用-go>开始使用 Go<a hidden class=anchor aria-hidden=true href=#开始使用-go>#</a></h2><p>我使用的 Go 版本是 1.16.7。但是，这里给出的命令应该也能在最新的版本上运行。如果你没有安装 Go，你可以从 <a href=https://go.dev/doc/install target=_blank rel="noopener noreferrer">Go 官网</a>
上下载它，并按照说明进行安装。你可以通过打开一个命令提示符，并键入下面的命令来验证你所安装的版本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go version
</span></span></code></pre></div><p>你应该会得到类似下面这样的输出，具体取决于你安装的版本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go version go1.16.7 linux/amd64
</span></span></code></pre></div><h2 id=基本的的编译和执行方法>基本的的编译和执行方法<a hidden class=anchor aria-hidden=true href=#基本的的编译和执行方法>#</a></h2><p>我将从一个在屏幕上简单打印 “Hello World” 的 Go 程序示例开始，就像下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span> <span class=nx>cat</span> <span class=nx>hello</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在讨论更高级的选项之前，我将解释如何编译这个 Go 示例程序。我使用了 <code>build</code> 命令，后面跟着 Go 程序的源文件名，本例中是 <code>hello.go</code>，就像下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build hello.go
</span></span></code></pre></div><p>如果一切工作正常，你应该看到在你的当前目录下创建了一个名为 <code>hello</code> 的可执行文件。你可以通过使用 <code>file</code> 命令验证它是 ELF 二进制可执行格式（在 Linux 平台上）。你也可以直接执行它，你会看到它输出 “Hello World”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>hello  hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ file ./hello
</span></span><span class=line><span class=cl>./hello: ELF 64-bit LSB executable, x86-64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, statically linked, not stripped
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./hello
</span></span><span class=line><span class=cl>Hello World
</span></span></code></pre></div><p>Go 提供了一个方便的 <code>run</code> 命令，以便你只是想看看程序是否能正常工作，并获得预期的输出，而不想生成一个最终的二进制文件。请记住，即使你在当前目录中没有看到可执行文件，Go 仍然会在某个地方编译并生成可执行文件并运行它，然后把它从系统中删除。我将在本文后面的章节中解释。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go run hello.go
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>hello.go
</span></span></code></pre></div><h2 id=更多细节>更多细节<a hidden class=anchor aria-hidden=true href=#更多细节>#</a></h2><p>上面的命令就像一阵风一样，一下子就运行完了我的程序。然而，如果你想知道 Go 在编译这些程序的过程中做了什么，Go 提供了一个 <code>-x</code> 选项，它可以打印出 Go 为产生这个可执行文件所做的一切。</p><p>简单看一下你就会发现，Go 在 <code>/tmp</code> 内创建了一个临时工作目录，并生成了可执行文件，然后把它移到了 Go 源程序所在的当前目录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build -x hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>WORK</span><span class=o>=</span>/tmp/go-build1944767317
</span></span><span class=line><span class=cl>mkdir -p <span class=nv>$WORK</span>/b001/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s>&lt;&lt; snip &gt;&gt;
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>mkdir -p $WORK/b001/exe/
</span></span></span><span class=line><span class=cl><span class=s>cd .
</span></span></span><span class=line><span class=cl><span class=s>/us</span>r/lib/golang/pkg/tool/linux_amd64/link -o <span class=nv>$WORK</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/b001/exe/a.out -importcfg <span class=nv>$WORK</span>/b001 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/importcfg.link -buildmode<span class=o>=</span>exe -buildid<span class=o>=</span>K26hEYzgDkqJjx2Hf-wz/<span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>nDueg0kBjIygx25rYwbK/W-eJaGIOdPEWgwC6o546 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/K26hEYzgDkqJjx2Hf-wz -extld<span class=o>=</span>gcc /root/.cache/go-build /cc <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/cc72cb2f4fbb61229885fc434995964a7a4d6e10692a23cc0ada6707c5d3435b-d
</span></span><span class=line><span class=cl>/usr/lib/golang/pkg/tool/linux_amd64/buildid -w <span class=nv>$WORK</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/b001/exe/a.out <span class=c1># internal</span>
</span></span><span class=line><span class=cl>mv <span class=nv>$WORK</span>/b001/exe/a.out hello
</span></span><span class=line><span class=cl>rm -r <span class=nv>$WORK</span>/b001/
</span></span></code></pre></div><p>这有助于解决在程序运行后却在当前目录下没有生成可执行文件的谜团。使用 <code>-x</code> 显示可执行文件确实在 <code>/tmp</code> 工作目录下创建并被执行了。然而，与 <code>build</code> 命令不同的是，可执行文件并没有移动到当前目录，这使得看起来没有可执行文件被创建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go run -x hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mkdir -p <span class=nv>$WORK</span>/b001/exe/
</span></span><span class=line><span class=cl><span class=nb>cd</span> .
</span></span><span class=line><span class=cl>/usr/lib/golang/pkg/tool/linux_amd64/link -o <span class=nv>$WORK</span>/b001 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/exe/hello -importcfg <span class=nv>$WORK</span>/b001/importcfg.link -s -w -buildmode<span class=o>=</span>exe -buildid<span class=o>=</span>hK3wnAP20DapUDeuvAAS/E_TzkbzwXz6tM5dEC8Mx <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/7HYBzuaDGVdaZwSMEWAa/hK3wnAP20DapUDeuvAAS -extld<span class=o>=</span>gcc <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>/root/.cache/go-build/75/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>7531fcf5e48444eed677bfc5cda1276a52b73c62ebac3aa99da3c4094fa57dc3-d
</span></span><span class=line><span class=cl><span class=nv>$WORK</span>/b001/exe/hello
</span></span><span class=line><span class=cl>Hello World
</span></span></code></pre></div><h2 id=模仿编译而不产生可执行文件>模仿编译而不产生可执行文件<a hidden class=anchor aria-hidden=true href=#模仿编译而不产生可执行文件>#</a></h2><p>假设你不想编译程序并产生一个实际的二进制文件，但你确实想看到这个过程中的所有步骤。你可以通过使用 <code>-n</code> 这个构建选项来做到这一点，该选项会打印出通常的执行步骤，而不会实际创建二进制文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build -n hello.go
</span></span></code></pre></div><h2 id=保存临时目录>保存临时目录<a hidden class=anchor aria-hidden=true href=#保存临时目录>#</a></h2><p>很多工作都发生在 <code>/tmp</code> 工作目录中，一旦可执行文件被创建和运行，它就会被删除。但是如果你想看看哪些文件是在编译过程中创建的呢？Go 提供了一个 <code>-work</code> 选项，它可以在编译程序时使用。<code>-work</code> 选项除了运行程序外，还打印了工作目录的路径，但它并不会在这之后删除工作目录，所以你可以切换到该目录，检查在编译过程中创建的所有文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go run -work hello.go
</span></span><span class=line><span class=cl><span class=nv>WORK</span><span class=o>=</span>/tmp/go-build3209320645
</span></span><span class=line><span class=cl>Hello World
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ find /tmp/go-build3209320645
</span></span><span class=line><span class=cl>/tmp/go-build3209320645
</span></span><span class=line><span class=cl>/tmp/go-build3209320645/b001
</span></span><span class=line><span class=cl>/tmp/go-build3209320645/b001/importcfg.link
</span></span><span class=line><span class=cl>/tmp/go-build3209320645/b001/exe
</span></span><span class=line><span class=cl>/tmp/go-build3209320645/b001/exe/hello
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ /tmp/go-build3209320645/b001/exe/hello
</span></span><span class=line><span class=cl>Hello World
</span></span></code></pre></div><h2 id=其他编译选项>其他编译选项<a hidden class=anchor aria-hidden=true href=#其他编译选项>#</a></h2><p>如果说，你想手动编译程序，而不是使用 Go 的 <code>build</code> 和 <code>run</code> 这两个方便的命令，最后得到一个可以直接由你的操作系统（这里指 Linux）运行的可执行文件。那么，你该怎么做呢？这个过程可以分为两部分：编译和链接。你可以使用 <code>tool</code> 选项来看看它是如何工作的。</p><p>首先，使用 <code>tool compile</code> 命令产生结果的 <code>ar</code> 归档文件，它包含了 <code>.o</code> 中间文件。接下来，对这个 <code>hello.o</code> 文件执行 <code>tool link</code> 命令，产生最终的可执行文件，然后你就可以运行它了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go tool compile hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ file hello.o
</span></span><span class=line><span class=cl>hello.o: current ar archive
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ar t hello.o
</span></span><span class=line><span class=cl>__.PKGDEF
</span></span><span class=line><span class=cl>_go_.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ go tool link -o hello hello.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ file hello
</span></span><span class=line><span class=cl>hello: ELF 64-bit LSB executable, x86-64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, statically linked, not stripped
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./hello
</span></span><span class=line><span class=cl>Hello World
</span></span></code></pre></div><p>如果你想进一步查看基于 <code>hello.o</code> 文件产生可执行文件的链接过程，你可以使用 <code>-v</code> 选项，它会搜索每个 Go 可执行文件中包含的 <code>runtime.a</code> 文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go tool link -v -o hello hello.o
</span></span><span class=line><span class=cl><span class=nv>HEADER</span> <span class=o>=</span> -H5 -T0x401000 -R0x1000
</span></span><span class=line><span class=cl>searching <span class=k>for</span> runtime.a in /usr/lib/golang/pkg/linux_amd64/runtime.a
</span></span><span class=line><span class=cl><span class=m>82052</span> symbols, <span class=m>18774</span> reachable
</span></span><span class=line><span class=cl>        <span class=m>1</span> package symbols, <span class=m>1106</span> hashed symbols, <span class=m>77185</span> non-package symbols, <span class=m>3760</span> external symbols
</span></span><span class=line><span class=cl><span class=m>81968</span> liveness data
</span></span></code></pre></div><h2 id=交叉编译选项>交叉编译选项<a hidden class=anchor aria-hidden=true href=#交叉编译选项>#</a></h2><p>现在我已经解释了 Go 程序的编译过程，接下来，我将演示 Go 如何通过在实际的 <code>build</code> 命令之前提供 <code>GOOS</code> 和 <code>GOARCH</code> 这两个环境变量，来允许你构建针对不同硬件架构和操作系统的可执行文件。</p><p>这有什么用呢？举个例子，你会发现为 ARM（arch64）架构制作的可执行文件不能在英特尔（x86_64）架构上运行，而且会产生一个 Exec 格式错误。</p><p>下面的这些选项使得生成跨平台的二进制文件变得小菜一碟：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nv>GOOS</span><span class=o>=</span>linux <span class=nv>GOARCH</span><span class=o>=</span>arm64 go build hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ file ./hello
</span></span><span class=line><span class=cl>./hello: ELF 64-bit LSB executable, ARM aarch64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, statically linked, not stripped
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./hello
</span></span><span class=line><span class=cl>bash: ./hello: cannot execute binary file: Exec format error
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ uname -m
</span></span><span class=line><span class=cl>x86_64
</span></span></code></pre></div><p>你可以阅读我之前的博文，以更多了解我在 <a href=https://opensource.com/article/21/1/go-cross-compiling target=_blank rel="noopener noreferrer">使用 Go 进行交叉编译</a>
方面的经验。</p><h2 id=查看底层汇编指令>查看底层汇编指令<a hidden class=anchor aria-hidden=true href=#查看底层汇编指令>#</a></h2><p>源代码并不会直接转换为可执行文件，尽管它生成了一种中间汇编格式，然后最终被组装为可执行文件。在 Go 中，这被映射为一种中间汇编格式，而不是底层硬件汇编指令。</p><p>要查看这个中间汇编格式，请在使用 <code>build</code> 命令时，提供 <code>-gcflags</code> 选项，后面跟着 <code>-S</code>。这个命令将会显示使用到的汇编指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build -gcflags<span class=o>=</span><span class=s2>&#34;-S&#34;</span> hello.go
</span></span><span class=line><span class=cl><span class=c1># command-line-arguments</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;</span>.main STEXT <span class=nv>size</span><span class=o>=</span><span class=m>138</span> <span class=nv>args</span><span class=o>=</span>0x0 <span class=nv>locals</span><span class=o>=</span>0x58 <span class=nv>funcid</span><span class=o>=</span>0x0
</span></span><span class=line><span class=cl>        0x0000 <span class=m>00000</span> <span class=o>(</span>/test/hello.go:5<span class=o>)</span> TEXT    <span class=s2>&#34;&#34;</span>.main<span class=o>(</span>SB<span class=o>)</span>, ABIInternal, <span class=nv>$88</span>-0
</span></span><span class=line><span class=cl>        0x0000 <span class=m>00000</span> <span class=o>(</span>/test/hello.go:5<span class=o>)</span> MOVQ    <span class=o>(</span>TLS<span class=o>)</span>, CX
</span></span><span class=line><span class=cl>        0x0009 <span class=m>00009</span> <span class=o>(</span>/test/hello.go:5<span class=o>)</span> CMPQ    SP, 16<span class=o>(</span>CX<span class=o>)</span>
</span></span><span class=line><span class=cl>        0x000d <span class=m>00013</span> <span class=o>(</span>/test/hello.go:5<span class=o>)</span> PCDATA  <span class=nv>$0</span>, <span class=nv>$-</span><span class=m>2</span>
</span></span><span class=line><span class=cl>        0x000d <span class=m>00013</span> <span class=o>(</span>/test/hello.go:5<span class=o>)</span> JLS     <span class=m>128</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt; snip &gt;&gt;
</span></span></code></pre></div><p>你也可以使用 <code>objdump -s</code> 选项，来查看已经编译好的可执行程序的汇编指令，就像下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ls
</span></span><span class=line><span class=cl>hello  hello.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ go tool objdump -s main.main hello
</span></span><span class=line><span class=cl>TEXT main.main<span class=o>(</span>SB<span class=o>)</span> /test/hello.go
</span></span><span class=line><span class=cl>  hello.go:5            0x4975a0                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX                  
</span></span><span class=line><span class=cl>  hello.go:5            0x4975a9                483b6110                CMPQ 0x10<span class=o>(</span>CX<span class=o>)</span>, SP                       
</span></span><span class=line><span class=cl>  hello.go:5            0x4975ad                <span class=m>7671</span>                    JBE 0x497620                            
</span></span><span class=line><span class=cl>  hello.go:5            0x4975af                4883ec58                SUBQ <span class=nv>$0</span>x58, SP                          
</span></span><span class=line><span class=cl>  hello.go:6            0x4975d8                <span class=m>4889442448</span>              MOVQ AX, 0x48<span class=o>(</span>SP<span class=o>)</span>                       
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt; snip &gt;&gt;
</span></span></code></pre></div><h2 id=分离二进制文件以减少其大小>分离二进制文件以减少其大小<a hidden class=anchor aria-hidden=true href=#分离二进制文件以减少其大小>#</a></h2><p>Go 的二进制文件通常比较大。例如, 一个简单的 “Hello World” 程序将会产生一个 1.9M 大小的二进制文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build hello.go
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ du -sh hello
</span></span><span class=line><span class=cl>1.9M    hello
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ file hello
</span></span><span class=line><span class=cl>hello: ELF 64-bit LSB executable, x86-64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, statically linked, not stripped
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><p>为了减少生成的二进制文件的大小，你可以分离执行过程中不需要的信息。使用 <code>-ldflags</code> 和 <code>-s -w</code> 选项可以使生成的二进制文件略微变小为 1.3M。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build -ldflags<span class=o>=</span><span class=s2>&#34;-s -w&#34;</span> hello.go
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ du -sh hello
</span></span><span class=line><span class=cl>1.3M    hello
</span></span><span class=line><span class=cl>$
</span></span><span class=line><span class=cl>$ file hello
</span></span><span class=line><span class=cl>hello: ELF 64-bit LSB executable, x86-64, version <span class=m>1</span> <span class=o>(</span>SYSV<span class=o>)</span>, statically linked, stripped
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>我希望这篇文章向你介绍了一些方便的 Go 编译选项，同时帮助了你更好地理解 Go 编译过程。关于构建过程的其他信息和其他有趣的选项，请参考 Go 命令帮助：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go <span class=nb>help</span> build
</span></span></code></pre></div><hr><blockquote><p>本文使用 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh target=_blank rel="noopener noreferrer">CC BY-SA 4.0 国际协议</a>
进行许可，欢迎 <strong>遵照协议规定</strong> 转载。<br>链接：<a href=https://lkxed.github.io/posts/go-build-options/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/go-build-options/</a><br>作者：<a href=https://opensource.com/users/gkamathe target=_blank rel="noopener noreferrer">Gaurav Kamathe</a>
/ 译者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>原文：<a href=https://opensource.com/article/22/4/go-build-options target=_blank rel="noopener noreferrer">My favorite build options for Go</a><br>首发：<a href=https://linux.cn/article-14525-1.html target=_blank rel="noopener noreferrer">我最喜欢的 Go 构建选项</a>
@ <a href=https://linux.cn/ target=_blank rel="noopener noreferrer">Linux 中国</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/%E8%AF%91%E6%96%87/>译文</a></li><li><a href=https://lkxed.github.io/tags/go/>Go</a></li><li><a href=https://lkxed.github.io/tags/%E4%BD%BF%E7%94%A8/>使用</a></li><li><a href=https://lkxed.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/shortwave-3-0-release/><span class=title>« 上一页</span><br><span>Shortwave 3.0 发布：用户界面更新、私人电台以及诸多改进</span></a>
<a class=next href=https://lkxed.github.io/posts/redis-distributed-locks-redlock/><span class=title>下一页 »</span><br><span>Redis 分布式锁：Redlock 算法</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function s(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>