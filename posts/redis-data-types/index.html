<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis 数据类型：简介｜六开箱</title><meta name=keywords content="Redis,数据类型,string,list,set,hash,zset"><meta name=description content="本文简单介绍了 Redis 支持的诸多数据类型。"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/redis-data-types/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="Redis 数据类型：简介"><meta property="og:description" content="本文简单介绍了 Redis 支持的诸多数据类型。"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/redis-data-types/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T18:58:16+08:00"><meta property="article:modified_time" content="2022-05-01T18:58:16+08:00"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-distributed-locks-redlock/"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-bulk-loading/"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-persistence-backup-recovery/"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-persistence-usage/"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-persistence-pros-cons/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 数据类型：简介"><meta name=twitter:description content="本文简单介绍了 Redis 支持的诸多数据类型。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis 数据类型：简介","item":"https://lkxed.github.io/posts/redis-data-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis 数据类型：简介","name":"Redis 数据类型：简介","description":"本文简单介绍了 Redis 支持的诸多数据类型。","keywords":["Redis","数据类型","string","list","set","hash","zset"],"articleBody":" 本文简单介绍了 Redis 支持的诸多数据类型。\n 前言 Redis 支持许多数据类型，尽管我们使用最多的仍然是 String。诚然，在大多数场景下，String 似乎都能够解决我们的问题，最多在程序中多几次转换而已。但是，Redis 提供的强大类型可以让我们省去许多复杂的逻辑，更重要的是，它总是会比我们自己实现有着更高的效率，不是吗？\nString String 是最基础的 Redis 数据类型。Redis 的 String 是二进制安全的，这意味着它可以储存任何种类的数据，例如 JPEG 图片或序列化的 Ruby 对象。\nString 值支持的最大长度是 512 MB。\n你可以使用 Redis 的 String 实现很多有意思的功能，比如你可以：\n 使用 String 实现一个原子计数器，结合 INCR 家族的命令：INCR、DECR 和 INCRBY 命令即可。 使用 APPEND 命令在 String 末尾追加值 使用 String 实现一个支持随机访问的向量，结合 GETRANGE 和 SETRANGE 命令即可。 使用少量空间来编码大量数据，或者创建一个基于 Redis 的布隆过滤器，结合 GETBIT 和 SETBIT 命令即可。  你可以查看 所有可用于 String 的命令 来了解更多。\nList Redis 的 List 就是一个 String 列表而已，它根据插入顺序排序。若要往 List 中插入数据，你即可以把数据添加到头部（左边），也可以把数据添加到尾部（右边）。\nLPUSH 命令用于添加数据到 List 左边，对应地，RPUSH 用于在 List 右边添加数据。当你对空 key 执行这两个命令时，你实际上就是在创建一个新 List，并给它添加了个 String 值。相似地，当你从一个大小为 1 的 List 中移除数据时，你其实就是在清空它。这是一个很方便的语法，因为当你调用 List 命令，而提供的参数 key 不存在时，你会像是在操作一个空 List，得到符合逻辑的结果。\n下面是一些 List 命令和它们的结果：\nLPUSH mylist a # 此时 mylist 的内容为 \"a\" LPUSH mylist b # 此时 mylist 的内容为 \"b\",\"a\" RPUSH mylist c # 此时 mylist 的内容为 \"b\",\"a\",\"c\"，因为使用的是 RPUSH List 的最大长度为 232 - 1，也就是说，每个 List 的最多可容纳超过 40 亿个元素（String）。\n从时间复杂度的角度来看，即使 List 中有数百万个元素，Redis 的 List 在头尾插入和删除也只耗费常数时间而已。访问接近头尾的元素是非常高效的，然而访问中间的元素的需要耗费 O(N) 的时间，其中 N 是 List 的长度。\n你可以使用 Redis 的 List 实现很多有意思的功能，比如你可以：\n 实现社交媒体的时间轴功能，使用 LPUSH 添加新元素到用户时间轴中，然后使用 LRANGE 来取出一些最近插入的元素。 你可以结合使用 LPUSH 和 LTRIM 来创建一个容量为 N 的 List，并且这个 List 只会储存最近添加的 N 个元素。 List 可以用来作为消息传递原语。比如，有一个用于创建后台任务的 Ruby 库叫做 Resque 。 你可以利用 List 做很多事，它支持很多命令，包括 BLPOP 等阻塞命令。  你可以查看 所有可用于 List 的命令 来了解更多。\nSet Redis 的 Set 是无序的 String 集合。它支持在 O(1) 的时间内执行添加元素、删除元素和检查元素是否存在等操作。O(1) 也就是说时间复杂度和 Set 的大小无关。\nRedis 的 Set 中不会有重复的元素。往 Set 中多次插入同一个元素，最终结果相当于只插入了一次。也就是说，在往 Set 中添加元素时，不需要预先检查元素是否存在。\n有趣的是，Set 支持很多服务端操作，它支持 Set 的计算。你可以对 Set 做并集、交集、差集等计算，它们只会耗费很少的时间。\nSet 的最大容量和 List 相同，也是 232 - 1，也就是超过 40 亿。\n你可以使用 Redis 的 Set 实现很多有意思的功能，比如你可以：\n 使用 Set 维护一些唯一的值。比如，你想知道访问某篇博客的所有不同 IP 吗？只需要在处理每次页面访问时，使用 SADD 把访客 IP 添加至 Set 中即可。这样一来，你会得到一个天然去重的 IP 集合。 Set 可以很好地表示关系。你可以使用不同 Set 来代表不同标签，接着，你可以使用 SADD 命令把所有标签相同的对象 ID 添加到它对应的 Set 中。你想要让每个对象同时拥有三个标签吗？只要使用 SINTER 就行了。 你可以使用 Set 来随机取元素，使用 SPOP 和 SRANDNUMBER 命令即可。  同样，你可以查看 所有可用于 Set 的命令 来了解更多。\nHash Redis 的 Hash 是一个 map，map 中每个键值对都是 String 类型，所以它很适合用来表示对象。比如说，可以用它来表示一个“用户”，拥有“名字”、“年龄”等属性，就像下面这样：\nHMSET user:1000 username antirez password P1pp0 age 34 HGETALL user:1000 HSET user:1000 password 12345 HGETALL user:1000 一个 Hash 可以有很多属性（最多 100 个左右），但它仅占用很少的空间，所以你可以在一个很小的 Redis 实例中储存几百万个对象（Hash）。\n虽然说 Hash 主要是用来表示对象，但它也可以储存很多元素，因此它也用处多多。\n每个 Hash 最多可以存 232 - 1（超过 40 亿）个键值对。\n你可以查看 所有可用于 Hash 的命令 来了解更多。\nSorted Set Redis 的 Sorted Set 与 Set 一样，也是一个无重复的 String 集合。它们的不同之处就在于，Sorted Set 的每一个成员都和一个分数score，它会根据这个分数来维持成员从小到大的顺序。每个成员都是不同的，但它们的分数可能会一样。\n对于 Sorted Set，你可以执行添加、删除或更新元素等操作，它们都十分高效，时间复杂度为 O(log(N))。由于元素是按序存储的，因此你可以高效地根据分数或位置来获取一个范围。即使是访问中间的元素也是很快的，因此你可以把 Sorted Set 作为一个无重复元素的列表：你可以快速访问任何元素，无论是按序反问、检查元素是否存在还是访问中间的元素！\n简而言之，对于 Sorted Set，你可以用它来完成非常多的任务，并且获得极佳性能，而这在其他数据库中是很难达到的。\n你可以使用 Redis 的 Sorted Set 实现很多有意思的功能，比如你可以：\n 实现一个大型在线游戏的排行榜，每当玩家提交分数，你就使用 ZADD 把它加入到 Sorted Set 中。你可以使用 ZRANGE 很轻松地获取名列前茅的用户。或者，给定一个用户名，你也可以使用 ZRANK 获得他的当前排名。结合使用 ZRANK 和 ZRANGE，你还可以实现获取“和指定用户分数相近的所有用户”的列表。所有操作都十分高效。 Sorted Set 通常用于给 Redis 中的数据添加索引。举个例子，假设你有很多的 Hash 来表示很多的用户，你可以把用户的年龄作为分数，把用户 ID 作为 value，建立一个 Sorted Set。这样，只要使用 ZRANGEBYSCORE，并给定年龄范围，你就可以快速得到所有符合条件的用户。  Sorted Set 是一种比较高级的 Redis 数据类型，因此，你可以查看 所有可用于 Sorted Set 的命令 来了解更多。\nBitmap 和 HyperLogLog Bitmap 和 HyperLogLog 其实是基于 Stirng 的数据类型，但是它们拥有独特的语义。\n（省略）\nStream Redis 的 Stream 是一种类似仅追加日志的数据结构。Stream 适用于按照出现顺序记录事件。你可以阅读 Redis streams 文档 来了解更多细节和使用。\nGeospatial index Redis 提供 地理空间索引Geospatial index，它对于查找给定半径的地理位置很有用。你可以使用 GEOADD 命令来往地理空间索引中添加位置。接着，你可以使用 GEORADIUS 命令来搜索给定半径内的位置。\n你可以阅读 地理空间索引的完整命令参考 来了解它的全部细节。\n后语 下一篇文章中，我将介绍如何使用 Redis 的发布/订阅功能。保持关注喔！\n  本文使用 CC BY-SA 4.0 国际协议 进行许可，欢迎 遵照协议规定 转载。\n作者：六开箱 链接：https://lkxed.github.io/posts/redis-data-types/  ","wordCount":"2697","inLanguage":"zh","datePublished":"2022-05-01T18:58:16+08:00","dateModified":"2022-05-01T18:58:16+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/redis-data-types/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis 数据类型：简介</h1><div class=post-meta><span title="2022-05-01 18:58:16 +0800 CST">2022 年 5 月 1 日 18:58</span>&nbsp;·&nbsp;2697 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#string aria-label=String>String</a></li><li><a href=#list aria-label=List>List</a></li><li><a href=#set aria-label=Set>Set</a></li><li><a href=#hash aria-label=Hash>Hash</a></li><li><a href=#sorted-set aria-label="Sorted Set">Sorted Set</a></li><li><a href=#bitmap-%e5%92%8c-hyperloglog aria-label="Bitmap 和 HyperLogLog">Bitmap 和 HyperLogLog</a></li><li><a href=#stream aria-label=Stream>Stream</a></li><li><a href=#geospatial-index aria-label="Geospatial index">Geospatial index</a></li><li><a href=#%e5%90%8e%e8%af%ad aria-label=后语>后语</a></li></ul></div></details></div><div class=post-content><blockquote><p>本文简单介绍了 Redis 支持的诸多数据类型。</p></blockquote><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>Redis 支持许多数据类型，尽管我们使用最多的仍然是 String。诚然，在大多数场景下，String 似乎都能够解决我们的问题，最多在程序中多几次转换而已。但是，Redis 提供的强大类型可以让我们省去许多复杂的逻辑，更重要的是，它总是会比我们自己实现有着更高的效率，不是吗？</p><h2 id=string>String<a hidden class=anchor aria-hidden=true href=#string>#</a></h2><p>String 是最基础的 Redis 数据类型。Redis 的 String 是二进制安全的，这意味着它可以储存任何种类的数据，例如 JPEG 图片或序列化的 Ruby 对象。</p><p>String 值支持的最大长度是 512 MB。</p><p>你可以使用 Redis 的 String 实现很多有意思的功能，比如你可以：</p><ul><li>使用 String 实现一个原子计数器，结合 INCR 家族的命令：<code>INCR</code>、<code>DECR </code>和 <code>INCRBY</code> 命令即可。</li><li>使用 <code>APPEND</code> 命令在 String 末尾追加值</li><li>使用 String 实现一个支持随机访问的向量，结合 <code>GETRANGE</code> 和 <code>SETRANGE</code> 命令即可。</li><li>使用少量空间来编码大量数据，或者创建一个基于 Redis 的布隆过滤器，结合 <code>GETBIT</code> 和 <code>SETBIT</code> 命令即可。</li></ul><p>你可以查看 <a href=https://redis.io/commands/#string target=_blank rel="noopener noreferrer">所有可用于 String 的命令</a>
来了解更多。</p><h2 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h2><p>Redis 的 List 就是一个 String 列表而已，它根据插入顺序排序。若要往 List 中插入数据，你即可以把数据添加到头部（左边），也可以把数据添加到尾部（右边）。</p><p><code>LPUSH</code> 命令用于添加数据到 List 左边，对应地，<code>RPUSH</code> 用于在 List 右边添加数据。当你对空 key 执行这两个命令时，你实际上就是在创建一个新 List，并给它添加了个 String 值。相似地，当你从一个大小为 1 的 List 中移除数据时，你其实就是在清空它。这是一个很方便的语法，因为当你调用 List 命令，而提供的参数 key 不存在时，你会像是在操作一个空 List，得到符合逻辑的结果。</p><p>下面是一些 List 命令和它们的结果：</p><pre tabindex=0><code>LPUSH mylist a   # 此时 mylist 的内容为 &#34;a&#34;
LPUSH mylist b   # 此时 mylist 的内容为 &#34;b&#34;,&#34;a&#34;
RPUSH mylist c   # 此时 mylist 的内容为 &#34;b&#34;,&#34;a&#34;,&#34;c&#34;，因为使用的是 RPUSH
</code></pre><p>List 的最大长度为 2<sup>32</sup> - 1，也就是说，每个 List 的最多可容纳超过 40 亿个元素（String）。</p><p>从时间复杂度的角度来看，即使 List 中有数百万个元素，Redis 的 List 在头尾插入和删除也只耗费常数时间而已。访问接近头尾的元素是非常高效的，然而访问中间的元素的需要耗费 O(N) 的时间，其中 N 是 List 的长度。</p><p>你可以使用 Redis 的 List 实现很多有意思的功能，比如你可以：</p><ul><li>实现社交媒体的时间轴功能，使用 <code>LPUSH</code> 添加新元素到用户时间轴中，然后使用 <code>LRANGE</code> 来取出一些最近插入的元素。</li><li>你可以结合使用 LPUSH 和 LTRIM 来创建一个容量为 N 的 List，并且这个 List 只会储存最近添加的 N 个元素。</li><li>List 可以用来作为消息传递原语。比如，有一个用于创建后台任务的 Ruby 库叫做 <a href=https://github.com/resque/resque target=_blank rel="noopener noreferrer">Resque</a>
。</li><li>你可以利用 List 做很多事，它支持很多命令，包括 <code>BLPOP</code> 等阻塞命令。</li></ul><p>你可以查看 <a href=https://redis.io/commands#list target=_blank rel="noopener noreferrer">所有可用于 List 的命令</a>
来了解更多。</p><h2 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h2><p>Redis 的 Set 是无序的 String 集合。它支持在 O(1) 的时间内执行添加元素、删除元素和检查元素是否存在等操作。O(1) 也就是说时间复杂度和 Set 的大小无关。</p><p>Redis 的 Set 中不会有重复的元素。往 Set 中多次插入同一个元素，最终结果相当于只插入了一次。也就是说，在往 Set 中添加元素时，不需要预先检查元素是否存在。</p><p>有趣的是，Set 支持很多服务端操作，它支持 Set 的计算。你可以对 Set 做并集、交集、差集等计算，它们只会耗费很少的时间。</p><p>Set 的最大容量和 List 相同，也是 2<sup>32</sup> - 1，也就是超过 40 亿。</p><p>你可以使用 Redis 的 Set 实现很多有意思的功能，比如你可以：</p><ul><li>使用 Set 维护一些唯一的值。比如，你想知道访问某篇博客的所有不同 IP 吗？只需要在处理每次页面访问时，使用 <code>SADD</code> 把访客 IP 添加至 Set 中即可。这样一来，你会得到一个天然去重的 IP 集合。</li><li>Set 可以很好地表示关系。你可以使用不同 Set 来代表不同标签，接着，你可以使用 <code>SADD</code> 命令把所有标签相同的对象 ID 添加到它对应的 Set 中。你想要让每个对象同时拥有三个标签吗？只要使用 <code>SINTER</code> 就行了。</li><li>你可以使用 Set 来随机取元素，使用 <code>SPOP</code> 和 <code>SRANDNUMBER</code> 命令即可。</li></ul><p>同样，你可以查看 <a href=https://redis.io/commands#set target=_blank rel="noopener noreferrer">所有可用于 Set 的命令</a>
来了解更多。</p><h2 id=hash>Hash<a hidden class=anchor aria-hidden=true href=#hash>#</a></h2><p>Redis 的 Hash 是一个 map，map 中每个键值对都是 String 类型，所以它很适合用来表示对象。比如说，可以用它来表示一个“用户”，拥有“名字”、“年龄”等属性，就像下面这样：</p><pre tabindex=0><code>HMSET user:1000 username antirez password P1pp0 age 34
HGETALL user:1000
HSET user:1000 password 12345
HGETALL user:1000
</code></pre><p>一个 Hash 可以有很多属性（最多 100 个左右），但它仅占用很少的空间，所以你可以在一个很小的 Redis 实例中储存几百万个对象（Hash）。</p><p>虽然说 Hash 主要是用来表示对象，但它也可以储存很多元素，因此它也用处多多。</p><p>每个 Hash 最多可以存 2<sup>32</sup> - 1（超过 40 亿）个键值对。</p><p>你可以查看 <a href=https://redis.io/commands#hash target=_blank rel="noopener noreferrer">所有可用于 Hash 的命令</a>
来了解更多。</p><h2 id=sorted-set>Sorted Set<a hidden class=anchor aria-hidden=true href=#sorted-set>#</a></h2><p>Redis 的 Sorted Set 与 Set 一样，也是一个无重复的 String 集合。它们的不同之处就在于，Sorted Set 的每一个成员都和一个<ruby>分数<rt>score</rt></ruby>，它会根据这个分数来维持成员从小到大的顺序。每个成员都是不同的，但它们的分数可能会一样。</p><p>对于 Sorted Set，你可以执行添加、删除或更新元素等操作，它们都十分高效，时间复杂度为 O(log(N))。由于元素是按序存储的，因此你可以高效地根据分数或位置来获取一个范围。即使是访问中间的元素也是很快的，因此你可以把 Sorted Set 作为一个无重复元素的列表：你可以快速访问任何元素，无论是按序反问、检查元素是否存在还是访问中间的元素！</p><p>简而言之，对于 Sorted Set，你可以用它来完成非常多的任务，并且获得极佳性能，而这在其他数据库中是很难达到的。</p><p>你可以使用 Redis 的 Sorted Set 实现很多有意思的功能，比如你可以：</p><ul><li>实现一个大型在线游戏的排行榜，每当玩家提交分数，你就使用 <code>ZADD</code> 把它加入到 Sorted Set 中。你可以使用 <code>ZRANGE</code> 很轻松地获取名列前茅的用户。或者，给定一个用户名，你也可以使用 <code>ZRANK</code> 获得他的当前排名。结合使用 <code>ZRANK</code> 和 <code>ZRANGE</code>，你还可以实现获取“和指定用户分数相近的所有用户”的列表。所有操作都十分高效。</li><li>Sorted Set 通常用于给 Redis 中的数据添加索引。举个例子，假设你有很多的 Hash 来表示很多的用户，你可以把用户的年龄作为分数，把用户 ID 作为 value，建立一个 Sorted Set。这样，只要使用 <code>ZRANGEBYSCORE</code>，并给定年龄范围，你就可以快速得到所有符合条件的用户。</li></ul><p>Sorted Set 是一种比较高级的 Redis 数据类型，因此，你可以查看 <a href=https://redis.io/commands#sorted_set target=_blank rel="noopener noreferrer">所有可用于 Sorted Set 的命令</a>
来了解更多。</p><h2 id=bitmap-和-hyperloglog>Bitmap 和 HyperLogLog<a hidden class=anchor aria-hidden=true href=#bitmap-和-hyperloglog>#</a></h2><p>Bitmap 和 HyperLogLog 其实是基于 Stirng 的数据类型，但是它们拥有独特的语义。</p><p>（省略）</p><h2 id=stream>Stream<a hidden class=anchor aria-hidden=true href=#stream>#</a></h2><p>Redis 的 Stream 是一种类似仅追加日志的数据结构。Stream 适用于按照出现顺序记录事件。你可以阅读 <a href=https://redis.io/docs/manual/data-types/streams target=_blank rel="noopener noreferrer">Redis streams 文档</a>
来了解更多细节和使用。</p><h2 id=geospatial-index>Geospatial index<a hidden class=anchor aria-hidden=true href=#geospatial-index>#</a></h2><p>Redis 提供 <ruby>地理空间索引<rt>Geospatial index</rt></ruby>，它对于查找给定半径的地理位置很有用。你可以使用 <code>GEOADD</code> 命令来往地理空间索引中添加位置。接着，你可以使用 <code>GEORADIUS</code> 命令来搜索给定半径内的位置。</p><p>你可以阅读 <a href="https://redis.io/docs/manual/data-types/commands/?group=geo" target=_blank rel="noopener noreferrer">地理空间索引的完整命令参考</a>
来了解它的全部细节。</p><h2 id=后语>后语<a hidden class=anchor aria-hidden=true href=#后语>#</a></h2><p>下一篇文章中，我将介绍如何使用 Redis 的发布/订阅功能。保持关注喔！</p><hr><blockquote><p>本文使用 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh target=_blank rel="noopener noreferrer">CC BY-SA 4.0 国际协议</a>
进行许可，欢迎 <strong>遵照协议规定</strong> 转载。<br>作者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>链接：<a href=https://lkxed.github.io/posts/redis-data-types/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/redis-data-types/</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/redis/>Redis</a></li><li><a href=https://lkxed.github.io/tags/%E7%AE%80%E4%BB%8B/>简介</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/redox-os-0-7-0-release/><span class=title>« 上一页</span><br><span>基于 Rust 的 Redox OS 0.7.0 发布：增强硬件支持</span></a>
<a class=next href=https://lkxed.github.io/posts/shortwave-3-0-release/><span class=title>下一页 »</span><br><span>Shortwave 3.0 发布：用户界面更新、私人电台以及诸多改进</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>