<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis 持久化：原理及使用｜六开箱</title><meta name=keywords content="Redis,持久化,RDB,AOF,使用,原理,教程"><meta name=description content="现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/redis-persistence-usage/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="Redis 持久化：原理及使用"><meta property="og:description" content="现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/redis-persistence-usage/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-25T19:52:43+08:00"><meta property="article:modified_time" content="2022-04-25T19:52:43+08:00"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-persistence-backup-recovery/"><meta property="og:see_also" content="https://lkxed.github.io/posts/redis-persistence-pros-cons/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 持久化：原理及使用"><meta name=twitter:description content="现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis 持久化：原理及使用","item":"https://lkxed.github.io/posts/redis-persistence-usage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis 持久化：原理及使用","name":"Redis 持久化：原理及使用","description":"现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？","keywords":["Redis","持久化","RDB","AOF","使用","原理","教程"],"articleBody":" 现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？\n 前言 一般来说，如果想拥有能与 PostgreSQL 相提并论的数据安全性的话，你应该同时使用这两种持久化方式。\n另一种常见的情况是，你很关心自己数据，但在故障时也可以接受几分钟的数据丢失，那么你只需要使用 RDB 就够了。\n不过，也有很多用户只用 AOF，我们并不建议这样做，因为时不时地生成一个 RDB 快照是个好主意。无论是考虑到数据备份，还是为了重启时更快的数据恢复速度，抑或是考虑到 AOF 引擎可能会出现错误。\n下面的部分将介绍更多关于这两种持久化方法的使用细节。\n快照（Snapshots / RDB） Redis 默认在磁盘中保存数据集的快照，它们会被保存在一个名为 dump.rdb 的二进制文件中。\n你可以设置 Redis，让它每隔 N 秒钟保存一次数据集，如果这段时间内至少有 M 次数据集修改的话。\n或者你也可以手动调用 SAVE 和 BGSAVE 命令。\n举例来说，下面的配置将会让 Redis 每隔 60 秒自动保存一次数据集，如果这段时间内至少有 1000 个 key 发生改变的话。\nsave 60 1000 这个策略也被称为 快照。\n工作原理 每当 Redis 需要保存数据集到磁盘中时，它会执行下面一系列操作：\n Redis 会 fork 一个子进程。 子进程开始把数据集写入到一个临时的 RDB 文件中。 当子进程写完了新的 RDB 文件，它会替换旧的 RDB 文件。  如此一来，Redis 可以从 copy-on-write 机制中受益了。\n仅追加文件（AOF） 快照的持久化程度还不够高。如果你的电脑运行的 Redis 停止，或者你的电源线坏了，抑或是你不小心执行 kill -9 杀死了你的 server 实例，那么最近写入 Redis 的数据将会丢失。\n虽然对于某些应用来说，这也不是什么大事；但对于另一些应用来说，它们可能非常依赖于持久化。\n在这种情况下，仅仅依靠快照来保证数据不丢失是不可行的。\n仅追加文件（AOF）是 Redis 的另一种持久化策略，它能够实现完全的持久化。Redis 自从 1.1 版本开始就支持 AOF 了。\n你可以在配置文件中开启 AOF，就像下面这样：\nappendonly yes 从现在开始，每当 Redis 接收到一个改变数据集的命令（比如 SET 命令），它都会被追加到 AOF 文件中。\n当 Redis 重启时，它将会重放 AOF 文件来重新构建数据集。\n从 7.0.0 版本开始，Redis 引入了分段 AOF 机制。\n分段 AOF 机制就是把单个 AOF 文件分割成了基准文件（最多一个）和增量文件（可能不止一个）。\n当 AOF 文件被重写时，基准文件代表了一个初始的（RDB 或 AOF 格式的）数据快照，而增量文件里则包含了上一个基准文件创建后的所有增量变更。\n所有的这些文件都被放置在一个独立的目录中，并被一个清单文件追踪。\n日志重写 随着写操作的执行，AOF 文件会越来越大。\n举个例子，如果你对计数器增加 100 次，你只会有一个包含最终结果的 key，但是你的 AOF 文件中却会有 100 条记录。\n当重建数据集的时候，这 100 条中的 99 条其实都是不必要的\n日志重写是完全安全的。Redis 会持续地往旧的文件中追加操作日志，与此同时，一个新的文件将被创建。这个新的文件里包含了构建当前数据集所需的最小集合。\n当这个新文件准备就绪时，Redis 会切换这两个文件，然后开始附加命令到新文件中。\n这样一来，Redis 支持了一个有趣的特性：它可以在后台重建 AOF 文件，而不会中断对客户端的服务。\n不管何时，只要你发送了 BGREWRITEAOF 命令，Redis 就会把重建当前数据集所需的最短命令序列写入到内存中。\n如果你正在使用 Redis 2.2 版本，你需要时不时地运行 BGREWRITEAOF 命令。因为 Redis 从 2.4 版本开始才支持自动触发日志重写（你可以查看示例配置文件了解更多信息）。\n从 7.0.0 版本开始，每当要 AOF 重写，Redis 父进程都会开启一个新的增量 AOF 文件来继续写入。子进程执行重写逻辑，并生成一个新的基准 AOF 文件。\nRedis 将会使用一个临时的清单来追踪新生成的基准文件和增量文件。当它们准备就绪，Redis 会执行一个原子替换操作，让这个临时文件开始生效。\n为了避免在重复失败、AOF 重写重试等情况下，创建太多增量文件的问题，Redis 引入了一个 AOF 重写限制机制，以此来保证失败的 AOF 重写的重试频率会越来越低。\nAOF 的 fsync 你可以设置 Redis 使用 fsync 来写数据到磁盘上的次数。下面是它的三个选项：\n appendfsync always：每当新命令追加到 AOF 文件中时，都会调用 fsync。这会非常非常慢，但是也非常安全。注意，每当执行完来自多个客户端的一批命令，或是执行了管道后，命令才会追加到 AOF 文件中。所以，这意味着每次写入命令都对应着一次 fsync 的调用（在服务端发送响应给客户端之前）。 appendfsync everysec：每秒钟调用一次 fsync。这足够快了（2.4 版本之后可能与快照一样快）。并且，假如发生故障，你最多也只会丢失 1 秒钟的数据而已。 appendfsync no：禁用 fsync。把数据交给操作系统管理。这是最快的，也是最不安全的做法。通常，Linux 系统会每隔 30 秒把数据刷新到磁盘中，不过这取决于内核具体是怎么设置的。  建议的（也是默认的）策略是每秒钟调用一次 fsync。这是一个既快又安全的选项。\n如果选用 always 的话，实践中表明它太慢了，但是它支持组提交group commit。因此如果有多个并行的写操作，Redis 会尝试只调用一次 fsync。\nAOF 截断 存在一种可能的情况，AOF 正在写入时 server 突然崩溃了，或者储存 AOF 的数据盘写满了。这时候 AOF 仍然包含了某个时间点的连续数据（默认的 AOF fsync 下可能已经是一秒钟以前的旧数据了），但是 AOF 的最后一条命令却被截断了。\n最新的 Redis 主要版本仍能加载 AOF 文件，只不过是忽略了最后一条格式错误的命令而已。\n在这种情况下，server 会打印出一条日志，类似下面这样：\n* Reading RDB preamble from AOF file... * Reading the remaining AOF tail... # !!! Warning: short read while loading the AOF file !!! # !!! Truncating the AOF at offset 439 !!! # AOF loaded anyway because aof-load-truncated is enabled 你可以改变这个默认配置，让 Redis 停止加载不完整的 AOF 文件。不过默认配置下，Redis 会忽略最后一条命令是否符合格式，仍然继续加载它，以此来保证重启后的可用性。\n在这种情况下，老版本的 Redis 可能不会自动恢复数据，你可能需要执行下面的步骤：\n 备份 AOF 文件。 使用 Redis 附带的 redis-check-aof 工具来修复原始的 AOF 文件：  $ redis-check-aof --fix   (可选)使用 diff -u 命令来比较这两个文件的差异。 有了修复后的文件，重启 Redis server。  AOF 混乱 如果 AOF 文件不仅是被截断了，而是被插入的无效的字节序列搞混乱了，那么情况就要复杂得多。\nRedis 会在启动时报错并终止，就像下面这样：\n* Reading the remaining AOF tail... # Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix  这时候，你唯一能做的事就是运行 redis-check-aof 工具，并不用 --fix 选项，然后试图理解问题出在哪里，跳转到它提示的位置，看看是否可能手动修复文件。\nAOF 使用和 Redis 协议相同的格式，因此它很容易手动修复。\n如果不行的话，你可以尝试让这个工具为我们修复（加上 --fix 选项），但是这样一来，AOF 文件中的出问题的位置之后的部门都会被丢弃，这也就意味着，如果错误发生在文件的开头部分，你将丢失大量的数据。\n工作原理 日志重写使用了 copy-on-write 机制，这个机制在快照中已经被使用。以下是它的工作方式：\nRedis 版本 = 7.0.0  Redis fork 一个子进程。 子进程开始在一个临时文件中写新的基准 AOF。 父进程打开一个新的增量 AOF 来继续写更新。如果重写失败，旧的基准和增量文件（如果存在的话）加上这个新打开的增量的 AOF 共同代表了完整的数据集，因此数据是安全的。 当子进程写完了基准文件，父进程会收到一个信号，然后使用新打开的增量文件和子进程生成的基准文件来构建一个临时清单，并将它保存。 准备就绪！现在 Redis 可以执行一个清单文件的原子交换，这样 AOF 重写的结果就会生效了。Redis 同时会清理旧的基准文件，以及所有不再使用的增量文件。  Redis 版本  Redis fork 一个子进程。 子进程开始在一个临时文件中写新的 AOF。 父进程将所有增量的新变更都暂存到一块内存缓冲里（同时它也在旧的 AOF 文件中写入，如此一来，当重写失败时，我们也是安全的）。 当子进程写完了新的 AOF，父进程会收到一个信号，然后将内存中的增量缓冲追加到新的 AOF 文件的末尾。 Redis 自动把临时文件（新文件）重命名为“旧文件名”（详见 GitHub Issue #1890 ），然后开始往新文件中写入数据。  从 RDB 切换到 AOF Redis 2.0 之前和之后版本的做法相差很大。你可以猜想在 Redis 2.2 版本之后切换变简单了，因为它不再需要重启了。\nRedis 版本 = 2.2  备份你最新的 dump.rdb 文件。 保存备份到一个安全的地方。 执行下面这两个命令：  redis-cli config set appendonly yes redis-cli config set save \"\"  确保你的数据库中包含了相同数量的 key。 确保所有写入都正确地追加到了 AOF 末尾。  第一个 CONFIG 命令启用了 AOF 持久化。\n第二个 CONFIG 命令用于关闭镜像（RDB）持久化。这是可选的，如果你愿意的话，你也可以保持开启这两个持久化方式。\n注意：请不要忘记在你的 redis.conf 文件中打开 AOF。不然当你重启 server 时，配置修改会丢失，server 会再次使用旧的配置。\nRedis 版本 == 2.0.0 （省略）\nAOF 与 RDB 的交互 Redis 2.4 及以上版本确保了当 RDB 快照操作进行中时，不会触发 AOF 重写。同样，在 AOF 重写进行中，不允许 BGSAVE 命令执行。\n这么做避免了两个 Redis 后台进程同时进行大量的磁盘 I/O 操作。\n当快照操作进行中，且用户使用 BGREWRITEAOF 命令显式地请求日志重写操作时，server 会返回 OK 状态码，告诉用户操作已经接收，然后重写将在快照操作结束后马上开始。\n当 AOF 和 RDB 持久化方式都开启时，Redis 会使用 AOF 文件来在重启时构建原始数据集，因为 AOF 能够确保数据是最完整的。\n后语 本文介绍了 RDB 与 AOF 各自的特点、使用场景和工作原理，还着重介绍了 AOF 使用过程中可能遇到的问题及其解决方法，以及 RDB 与 AOF 之间的交互。\n相信你在阅读完本文之后，可以根据自己的需要，选择合适的 Redis 持久化方式了吧！\n下一篇文章，我将介绍 Redis 的数据备份与灾难恢复。保持关注喔！\n参考资料 Redis Documentation - Redis persistence   本文使用 CC BY-SA 4.0 国际协议 进行许可，欢迎遵照协议规定转载。\n作者：六开箱 链接：https://lkxed.github.io/posts/redis-persistence-usage/  ","wordCount":"3819","inLanguage":"zh","datePublished":"2022-04-25T19:52:43+08:00","dateModified":"2022-04-25T19:52:43+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/redis-persistence-usage/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis 持久化：原理及使用</h1><div class=post-meta><span title="2022-04-25 19:52:43 +0800 CST">2022 年 4 月 25 日</span>&nbsp;·&nbsp;3819 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%bf%ab%e7%85%a7snapshots--rdb aria-label="快照（Snapshots / RDB）">快照（Snapshots / RDB）</a><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label=工作原理>工作原理</a></li></ul></li><li><a href=#%e4%bb%85%e8%bf%bd%e5%8a%a0%e6%96%87%e4%bb%b6aof aria-label=仅追加文件（AOF）>仅追加文件（AOF）</a><ul><li><a href=#%e6%97%a5%e5%bf%97%e9%87%8d%e5%86%99 aria-label=日志重写>日志重写</a></li><li><a href=#aof-%e7%9a%84-fsync aria-label="AOF 的 fsync">AOF 的 fsync</a></li><li><a href=#aof-%e6%88%aa%e6%96%ad aria-label="AOF 截断">AOF 截断</a></li><li><a href=#aof-%e6%b7%b7%e4%b9%b1 aria-label="AOF 混乱">AOF 混乱</a></li><li><a href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-1 aria-label=工作原理>工作原理</a><ul><li><a href=#redis-%e7%89%88%e6%9c%ac--700 aria-label="Redis 版本 &amp;gt;= 7.0.0">Redis 版本 >= 7.0.0</a></li><li><a href=#redis-%e7%89%88%e6%9c%ac--700-1 aria-label="Redis 版本 &amp;lt; 7.0.0">Redis 版本 &lt; 7.0.0</a></li></ul></li><li><a href=#%e4%bb%8e-rdb-%e5%88%87%e6%8d%a2%e5%88%b0-aof aria-label="从 RDB 切换到 AOF">从 RDB 切换到 AOF</a><ul><li><a href=#redis-%e7%89%88%e6%9c%ac--22 aria-label="Redis 版本 &amp;gt;= 2.2">Redis 版本 >= 2.2</a></li><li><a href=#redis-%e7%89%88%e6%9c%ac--200 aria-label="Redis 版本 == 2.0.0">Redis 版本 == 2.0.0</a></li></ul></li></ul></li><li><a href=#aof-%e4%b8%8e-rdb-%e7%9a%84%e4%ba%a4%e4%ba%92 aria-label="AOF 与 RDB 的交互">AOF 与 RDB 的交互</a></li><li><a href=#%e5%90%8e%e8%af%ad aria-label=后语>后语</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><blockquote><p>现在，我们已经知道 Redis 持久化的两种方式（RDB 与 AOF）的优缺点了。那么，我们该选用哪一种呢？</p></blockquote><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>一般来说，如果想拥有能与 PostgreSQL 相提并论的数据安全性的话，你应该同时使用这两种持久化方式。</p><p>另一种常见的情况是，你很关心自己数据，但在故障时也可以接受几分钟的数据丢失，那么你只需要使用 RDB 就够了。</p><p>不过，也有很多用户只用 AOF，我们并不建议这样做，因为时不时地生成一个 RDB 快照是个好主意。无论是考虑到数据备份，还是为了重启时更快的数据恢复速度，抑或是考虑到 AOF 引擎可能会出现错误。</p><p>下面的部分将介绍更多关于这两种持久化方法的使用细节。</p><h2 id=快照snapshots--rdb>快照（Snapshots / RDB）<a hidden class=anchor aria-hidden=true href=#快照snapshots--rdb>#</a></h2><p>Redis 默认在磁盘中保存数据集的快照，它们会被保存在一个名为 <code>dump.rdb</code> 的二进制文件中。</p><p>你可以设置 Redis，让它每隔 N 秒钟保存一次数据集，如果这段时间内至少有 M 次数据集修改的话。</p><p>或者你也可以手动调用 <code>SAVE</code> 和 <code>BGSAVE</code> 命令。</p><p>举例来说，下面的配置将会让 Redis 每隔 60 秒自动保存一次数据集，如果这段时间内至少有 1000 个 key 发生改变的话。</p><pre tabindex=0><code>save 60 1000
</code></pre><p>这个策略也被称为 <em>快照</em>。</p><h3 id=工作原理>工作原理<a hidden class=anchor aria-hidden=true href=#工作原理>#</a></h3><p>每当 Redis 需要保存数据集到磁盘中时，它会执行下面一系列操作：</p><ul><li>Redis 会 fork 一个子进程。</li><li>子进程开始把数据集写入到一个临时的 RDB 文件中。</li><li>当子进程写完了新的 RDB 文件，它会替换旧的 RDB 文件。</li></ul><p>如此一来，Redis 可以从 copy-on-write 机制中受益了。</p><h2 id=仅追加文件aof>仅追加文件（AOF）<a hidden class=anchor aria-hidden=true href=#仅追加文件aof>#</a></h2><p>快照的持久化程度还不够高。如果你的电脑运行的 Redis 停止，或者你的电源线坏了，抑或是你不小心执行 <code>kill -9</code> 杀死了你的 server 实例，那么最近写入 Redis 的数据将会丢失。</p><p>虽然对于某些应用来说，这也不是什么大事；但对于另一些应用来说，它们可能非常依赖于持久化。</p><p>在这种情况下，仅仅依靠快照来保证数据不丢失是不可行的。</p><p>仅追加文件（AOF）是 Redis 的另一种持久化策略，它能够实现完全的持久化。Redis 自从 1.1 版本开始就支持 AOF 了。</p><p>你可以在配置文件中开启 AOF，就像下面这样：</p><pre tabindex=0><code>appendonly yes
</code></pre><p>从现在开始，每当 Redis 接收到一个改变数据集的命令（比如 <code>SET</code> 命令），它都会被追加到 AOF 文件中。</p><p>当 Redis 重启时，它将会重放 AOF 文件来重新构建数据集。</p><p>从 7.0.0 版本开始，Redis 引入了分段 AOF 机制。</p><p>分段 AOF 机制就是把单个 AOF 文件分割成了基准文件（最多一个）和增量文件（可能不止一个）。</p><p>当 AOF 文件被重写时，基准文件代表了一个初始的（RDB 或 AOF 格式的）数据快照，而增量文件里则包含了上一个基准文件创建后的所有增量变更。</p><p>所有的这些文件都被放置在一个独立的目录中，并被一个清单文件追踪。</p><h3 id=日志重写>日志重写<a hidden class=anchor aria-hidden=true href=#日志重写>#</a></h3><p>随着写操作的执行，AOF 文件会越来越大。</p><p>举个例子，如果你对计数器增加 100 次，你只会有一个包含最终结果的 key，但是你的 AOF 文件中却会有 100 条记录。</p><p>当重建数据集的时候，这 100 条中的 99 条其实都是不必要的</p><p>日志重写是完全安全的。Redis 会持续地往旧的文件中追加操作日志，与此同时，一个新的文件将被创建。这个新的文件里包含了构建当前数据集所需的最小集合。</p><p>当这个新文件准备就绪时，Redis 会切换这两个文件，然后开始附加命令到新文件中。</p><p>这样一来，Redis 支持了一个有趣的特性：它可以在后台重建 AOF 文件，而不会中断对客户端的服务。</p><p>不管何时，只要你发送了 <code>BGREWRITEAOF</code> 命令，Redis 就会把重建当前数据集所需的最短命令序列写入到内存中。</p><p>如果你正在使用 Redis 2.2 版本，你需要时不时地运行 <code>BGREWRITEAOF</code> 命令。因为 Redis 从 2.4 版本开始才支持自动触发日志重写（你可以查看示例配置文件了解更多信息）。</p><p>从 7.0.0 版本开始，每当要 AOF 重写，Redis 父进程都会开启一个新的增量 AOF 文件来继续写入。子进程执行重写逻辑，并生成一个新的基准 AOF 文件。</p><p>Redis 将会使用一个临时的清单来追踪新生成的基准文件和增量文件。当它们准备就绪，Redis 会执行一个原子替换操作，让这个临时文件开始生效。</p><p>为了避免在重复失败、AOF 重写重试等情况下，创建太多增量文件的问题，Redis 引入了一个 AOF 重写限制机制，以此来保证失败的 AOF 重写的重试频率会越来越低。</p><h3 id=aof-的-fsync>AOF 的 fsync<a hidden class=anchor aria-hidden=true href=#aof-的-fsync>#</a></h3><p>你可以设置 Redis 使用 <code>fsync</code> 来写数据到磁盘上的次数。下面是它的三个选项：</p><ul><li><code>appendfsync always</code>：每当新命令追加到 AOF 文件中时，都会调用 <code>fsync</code>。这会非常非常慢，但是也非常安全。注意，每当执行完来自多个客户端的一批命令，或是执行了管道后，命令才会追加到 AOF 文件中。所以，这意味着每次写入命令都对应着一次 <code>fsync</code> 的调用（在服务端发送响应给客户端之前）。</li><li><code>appendfsync everysec</code>：每秒钟调用一次 <code>fsync</code>。这足够快了（2.4 版本之后可能与快照一样快）。并且，假如发生故障，你最多也只会丢失 1 秒钟的数据而已。</li><li><code>appendfsync no</code>：禁用 <code>fsync</code>。把数据交给操作系统管理。这是最快的，也是最不安全的做法。通常，Linux 系统会每隔 30 秒把数据刷新到磁盘中，不过这取决于内核具体是怎么设置的。</li></ul><p>建议的（也是默认的）策略是每秒钟调用一次 <code>fsync</code>。这是一个既快又安全的选项。</p><p>如果选用 <code>always</code> 的话，实践中表明它太慢了，但是它支持<ruby>组提交<rt>group commit</rt></ruby>。因此如果有多个并行的写操作，Redis 会尝试只调用一次 <code>fsync</code>。</p><h3 id=aof-截断>AOF 截断<a hidden class=anchor aria-hidden=true href=#aof-截断>#</a></h3><p>存在一种可能的情况，AOF 正在写入时 server 突然崩溃了，或者储存 AOF 的数据盘写满了。这时候 AOF 仍然包含了某个时间点的连续数据（默认的 AOF fsync 下可能已经是一秒钟以前的旧数据了），但是 AOF 的最后一条命令却被截断了。</p><p>最新的 Redis 主要版本仍能加载 AOF 文件，只不过是忽略了最后一条格式错误的命令而已。</p><p>在这种情况下，server 会打印出一条日志，类似下面这样：</p><pre tabindex=0><code>* Reading RDB preamble from AOF file...
* Reading the remaining AOF tail...
# !!! Warning: short read while loading the AOF file !!!
# !!! Truncating the AOF at offset 439 !!!
# AOF loaded anyway because aof-load-truncated is enabled
</code></pre><p>你可以改变这个默认配置，让 Redis 停止加载不完整的 AOF 文件。不过默认配置下，Redis 会忽略最后一条命令是否符合格式，仍然继续加载它，以此来保证重启后的可用性。</p><p>在这种情况下，老版本的 Redis 可能不会自动恢复数据，你可能需要执行下面的步骤：</p><ul><li>备份 AOF 文件。</li><li>使用 Redis 附带的 <code>redis-check-aof</code> 工具来修复原始的 AOF 文件：</li></ul><pre tabindex=0><code>$ redis-check-aof --fix &lt;filename&gt;
</code></pre><ul><li>(可选)使用 <code>diff -u</code> 命令来比较这两个文件的差异。</li><li>有了修复后的文件，重启 Redis server。</li></ul><h3 id=aof-混乱>AOF 混乱<a hidden class=anchor aria-hidden=true href=#aof-混乱>#</a></h3><p>如果 AOF 文件不仅是被截断了，而是被插入的无效的字节序列搞混乱了，那么情况就要复杂得多。</p><p>Redis 会在启动时报错并终止，就像下面这样：</p><pre tabindex=0><code>* Reading the remaining AOF tail...
# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;
</code></pre><p>这时候，你唯一能做的事就是运行 <code>redis-check-aof</code> 工具，并不用 <code>--fix</code> 选项，然后试图理解问题出在哪里，跳转到它提示的位置，看看是否可能手动修复文件。</p><p>AOF 使用和 Redis 协议相同的格式，因此它很容易手动修复。</p><p>如果不行的话，你可以尝试让这个工具为我们修复（加上 <code>--fix</code> 选项），但是这样一来，AOF 文件中的出问题的位置之后的部门都会被丢弃，这也就意味着，如果错误发生在文件的开头部分，你将丢失大量的数据。</p><h3 id=工作原理-1>工作原理<a hidden class=anchor aria-hidden=true href=#工作原理-1>#</a></h3><p>日志重写使用了 copy-on-write 机制，这个机制在快照中已经被使用。以下是它的工作方式：</p><h4 id=redis-版本--700>Redis 版本 >= 7.0.0<a hidden class=anchor aria-hidden=true href=#redis-版本--700>#</a></h4><ul><li>Redis fork 一个子进程。</li><li>子进程开始在一个临时文件中写新的基准 AOF。</li><li>父进程打开一个新的增量 AOF 来继续写更新。如果重写失败，旧的基准和增量文件（如果存在的话）加上这个新打开的增量的 AOF 共同代表了完整的数据集，因此数据是安全的。</li><li>当子进程写完了基准文件，父进程会收到一个信号，然后使用新打开的增量文件和子进程生成的基准文件来构建一个临时清单，并将它保存。</li><li>准备就绪！现在 Redis 可以执行一个清单文件的原子交换，这样 AOF 重写的结果就会生效了。Redis 同时会清理旧的基准文件，以及所有不再使用的增量文件。</li></ul><h4 id=redis-版本--700-1>Redis 版本 &lt; 7.0.0<a hidden class=anchor aria-hidden=true href=#redis-版本--700-1>#</a></h4><ul><li>Redis fork 一个子进程。</li><li>子进程开始在一个临时文件中写新的 AOF。</li><li>父进程将所有增量的新变更都暂存到一块内存缓冲里（同时它也在旧的 AOF 文件中写入，如此一来，当重写失败时，我们也是安全的）。</li><li>当子进程写完了新的 AOF，父进程会收到一个信号，然后将内存中的增量缓冲追加到新的 AOF 文件的末尾。</li><li>Redis 自动把临时文件（新文件）重命名为“旧文件名”（详见 GitHub Issue <a href=https://github.com/redis/redis-doc/issues/1890 target=_blank rel="noopener noreferrer">#1890</a>
），然后开始往新文件中写入数据。</li></ul><h3 id=从-rdb-切换到-aof>从 RDB 切换到 AOF<a hidden class=anchor aria-hidden=true href=#从-rdb-切换到-aof>#</a></h3><p>Redis 2.0 之前和之后版本的做法相差很大。你可以猜想在 Redis 2.2 版本之后切换变简单了，因为它不再需要重启了。</p><h4 id=redis-版本--22>Redis 版本 >= 2.2<a hidden class=anchor aria-hidden=true href=#redis-版本--22>#</a></h4><ul><li>备份你最新的 <code>dump.rdb</code> 文件。</li><li>保存备份到一个安全的地方。</li><li>执行下面这两个命令：</li></ul><pre tabindex=0><code>redis-cli config set appendonly yes
</code></pre><pre tabindex=0><code>redis-cli config set save &#34;&#34;
</code></pre><ul><li>确保你的数据库中包含了相同数量的 key。</li><li>确保所有写入都正确地追加到了 AOF 末尾。</li></ul><p>第一个 <code>CONFIG</code> 命令启用了 AOF 持久化。</p><p>第二个 <code>CONFIG</code> 命令用于关闭镜像（RDB）持久化。这是可选的，如果你愿意的话，你也可以保持开启这两个持久化方式。</p><p><strong>注意</strong>：请不要忘记在你的 <code>redis.conf</code> 文件中打开 AOF。不然当你重启 server 时，配置修改会丢失，server 会再次使用旧的配置。</p><h4 id=redis-版本--200>Redis 版本 == 2.0.0<a hidden class=anchor aria-hidden=true href=#redis-版本--200>#</a></h4><p>（省略）</p><h2 id=aof-与-rdb-的交互>AOF 与 RDB 的交互<a hidden class=anchor aria-hidden=true href=#aof-与-rdb-的交互>#</a></h2><p>Redis 2.4 及以上版本确保了当 RDB 快照操作进行中时，不会触发 AOF 重写。同样，在 AOF 重写进行中，不允许 <code>BGSAVE</code> 命令执行。</p><p>这么做避免了两个 Redis 后台进程同时进行大量的磁盘 I/O 操作。</p><p>当快照操作进行中，且用户使用 <code>BGREWRITEAOF</code> 命令显式地请求日志重写操作时，server 会返回 OK 状态码，告诉用户操作已经接收，然后重写将在快照操作结束后马上开始。</p><p>当 AOF 和 RDB 持久化方式都开启时，Redis 会使用 AOF 文件来在重启时构建原始数据集，因为 AOF 能够确保数据是最完整的。</p><h2 id=后语>后语<a hidden class=anchor aria-hidden=true href=#后语>#</a></h2><p>本文介绍了 RDB 与 AOF 各自的特点、使用场景和工作原理，还着重介绍了 AOF 使用过程中可能遇到的问题及其解决方法，以及 RDB 与 AOF 之间的交互。</p><p>相信你在阅读完本文之后，可以根据自己的需要，选择合适的 Redis 持久化方式了吧！</p><p>下一篇文章，我将介绍 Redis 的<strong>数据备份</strong>与<strong>灾难恢复</strong>。保持关注喔！</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://redis.io/docs/manual/persistence/ target=_blank rel="noopener noreferrer">Redis Documentation - Redis persistence</a></p><hr><blockquote><p>本文使用 <a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh target=_blank rel="noopener noreferrer">CC BY-SA 4.0 国际协议</a>
进行许可，欢迎<strong>遵照协议规定</strong>转载。<br>作者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>链接：<a href=https://lkxed.github.io/posts/redis-persistence-usage/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/redis-persistence-usage/</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/redis/>Redis</a></li><li><a href=https://lkxed.github.io/tags/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>工作原理</a></li><li><a href=https://lkxed.github.io/tags/%E7%AE%80%E4%BB%8B/>简介</a></li><li><a href=https://lkxed.github.io/tags/%E4%BD%BF%E7%94%A8/>使用</a></li><li><a href=https://lkxed.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/redis-persistence-backup-recovery/><span class=title>« 上一页</span><br><span>Redis 持久化：备份与恢复</span></a>
<a class=next href=https://lkxed.github.io/posts/how-c-programming-language-has-grown/><span class=title>下一页 »</span><br><span>C 语言：发展简史</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>