<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go string：正确删除子串｜六开箱</title><meta name=keywords content="Go,string,trim,Left,Right,Prefix,Suffix"><meta name=description content="字符串操作有很多，删除指定子串是最常见的操作的之一。然而，面对各种不同的需求，它或许没有看起来的那么简单。"><meta name=author content="六开箱"><link rel=canonical href=https://lkxed.github.io/posts/go-string-trim/><link crossorigin=anonymous href=/assets/css/stylesheet.min.09b98575a0a9c52a0dcff6660328188f9365049be8c47253f3072a85d10d82a5.css integrity="sha256-CbmFdaCpxSoNz/ZmAygYj5NlBJvoxHJT8wcqhdENgqU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lkxed.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lkxed.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lkxed.github.io/favicon-32x32.png><link rel=manifest href=https://lkxed.github.io/site.webmanifest><link rel=apple-touch-icon href=https://lkxed.github.io/apple-touch-icon.png><link rel=mask-icon href=https://lkxed.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f5f5f5" media="(prefers-color-scheme: light)"><meta name=theme-color content="#1d1e20" media="(prefers-color-scheme: dark)"><meta name=msapplication-TileColor content="#ffffff"><noscript><style>.top-link{display:none}</style></noscript><meta name=shenma-site-verification content="0834e815906a93375245a759f409f8b0_1648880760"><meta name=baidu-site-verification content="code-2I1Hg4GETM"><meta name=google-site-verification content="xBkkt93v_nso_R-2aQ-An4rbc_Gi_4rNFi8oBEKDNjc"><meta property="og:title" content="Go string：正确删除子串"><meta property="og:description" content="字符串操作有很多，删除指定子串是最常见的操作的之一。然而，面对各种不同的需求，它或许没有看起来的那么简单。"><meta property="og:type" content="article"><meta property="og:url" content="https://lkxed.github.io/posts/go-string-trim/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-23T11:59:43+08:00"><meta property="article:modified_time" content="2022-04-23T11:59:43+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go string：正确删除子串"><meta name=twitter:description content="字符串操作有很多，删除指定子串是最常见的操作的之一。然而，面对各种不同的需求，它或许没有看起来的那么简单。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://lkxed.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Go string：正确删除子串","item":"https://lkxed.github.io/posts/go-string-trim/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go string：正确删除子串","name":"Go string：正确删除子串","description":"字符串操作有很多，删除指定子串是最常见的操作的之一。然而，面对各种不同的需求，它或许没有看起来的那么简单。","keywords":["Go","string","trim","Left","Right","Prefix","Suffix"],"articleBody":"前言 在编写 [lctt-client][1] 时，我遇到了很多处理文件名的需求，其中最典型的莫过于 [生成符合规范的 Git 分支名称][2]。\n在 Git 分支命名规则中，有几个条件是在限制开头和末尾不能包含指定的字符（串）。\n这就要求我们必须把不符合规则的字符（串）替换掉，否则会因为分支名称不合法而无法创建该分支。\n如果你用过 GitHub Desktop 的话，你可能会注意到：当你使用它创建分支，并输入一个不合规的名称时，它自动把名称里的“坏分子”删除或是替换成 -，然后给你提示。\n如果我们自己要实现这一点的话，就必须使用到许多字符串操作的函数，其中就包括在字符串内指定的子串。\nstrings 包函数 Go 的内置包 strings 提供了一系列字符串操作的函数，其中有几个专门用来删除字符串中的指定字符，它们能帮上忙吗？\n删除空格 首先，我们先来看看 strings.TrimSpace 函数，它可以将字符串首尾的空格“删除”，然后返回首尾不含空格的字符串。\n之所以我要给“删除”加上引号，是因为空格并没有真的被删除，事实上，原来的字符串没有发生任何改变。\n这个函数真正做的是：找到开头第一个非空格字符，然后找到末尾第一个非空格字符，记住它们的下标，然后返回介于它们之间的一个字符串切片。\n事实上，strings 包内提供了所有字符串操作都是如此，因为 Go 中的 string 被设计为不可变类型。\n无论如何，从结果来看，它是符合期望的。不过，我们可能用不上它，因为 Git 分支名称的任意位置都不许包含空格，不仅是首尾而已。\n因此，在这种情况下，strings.ReplaceAll 会是更好的选择，它能够一次性删除包含所有的指定子串（只需要把它们替换为空串即可）。但它不是本文研究的重点，因此我们先把它搁置一旁。\n删除前缀 如果你只是想要删除字符串开头的某个子串，你可能会选择这个函数，毕竟它乍一看非常符合你的需求。\n但是，它并不是一个正确的选择。你可能会疑惑，尤其是当你曾经使用过它，并且也得到了符合预期的输出时。\n考虑下面这个例子：\n// extractSentence 从一个给定的 quote（句子）中删除开头的 speaker（说话者）， // 从而提取出并返回一个修改后的新字符串 func extractSentence(quote string, speaker string) string { leading := speaker + \": \" return strings.TrimLeft(quote, leading) } func TestExtractSentence(t *testing.T) { quote := \"LKXED: What do you think of it?\" speaker := \"LKXED\" want := \"What do you think of it?\" got := extractSentence(quote, speaker) if got != want { log.Faltalf(\"Test failed. Want %s, but got %s.\", want, got) } fmt.Println(got) } 在这个例子中，你写了一个提取句子的函数，还有针对它的单元测试。\n你发现自己果然可以得到预期输出 “What do you think of it?”，你兴高采烈地开始基于它实现新的功能。\n直到有一天，你的程序传进来一个不凑巧的 quote，内容是 “LKXED: Looks good to me.”，猜猜你最终会得到什么？\n出人意料地，你得到了 “ooks good to me.”，开头的 “L” 被某种神秘力量吃掉了。\n这是怎么回事呢？\n仔细看 strings.TrimLeft 的函数注释，你就会发现，它并不是在删除某个指定的前缀子串，而是在删除某个指定的字符集合：\n // TrimLeft returns a slice of the string s with all leading\n// Unicode code points contained in cutset removed.\n//\n// To remove a prefix, use TrimPrefix instead.\n 具体来说，它会从第一个字符开始，按序逐个检查当前字符是否属于给定的字符集合，直到找到一个不满足条件的字符为止，然后返回字符串的剩余部分。\n它还好心地提示了我们，如果需要删除一个指定的前缀，我们应该使用 strings.TrimPrefix 函数。\n将上述例子中的 strings.TrimLeft 修改为 strings.TrimPrefix，测试通过，打印出了符合预期的 “Looks good to me.”。\n原来，strings.TrimPrefix 的不同之处在于，它是真的在匹配前缀子串，并且需要子串完全匹配才行，否则就会返回原字符串，徒劳无功。\n删除后缀 经过了上面的教训，这是时候你应该能够正确地选择 strings.TrimSuffix 来完成这个功能。\n值得指出的是，对于文件名而言，这里的“后缀”通常会是文件扩展名。\n对于特定的某一类文件，它的扩展名通常是固定的，可如果你的应用涉及到多种类型的文件，你可能需要想办法获取它们的扩展名才行。\n事实上，当涉及到“文件路径”时，path 包内的函数通常都是有帮助的。比如你可能会需要的 path.Ext。\npath.Ext 只做了一件事：获取文件的扩展名。你可以结合它与 strings.TrimSuffix 来完成提取文件名的任务，就像下面这样：\n// filenameWithoutExt 从 filename 中提取不含扩展名的文件名 func filenameWithoutExt(filename string) string { ext := path.Ext(filename) filename = strings.TrimSuffix(filename, ext) return filename } func TestFilenameWithoutExt(t *testing.T) { filename := \"The Go Programming Language.pdf\" want := \"The Go Programming Language\" got := filenameWithoutExt(filename) if got != want { t.Fatalf(`want \"%s\", but got \"%s\".`, want, got) } fmt.Println(got) } 自定义删除逻辑 如果你既不想要删除前后缀，也不想要删除指定的首尾字符集合，那么，你可以试试 strings.TrimLeftFunc 和 strings.TrimRightFunc。\n这两个函数都支持让你提供一个 func(r rune) bool 函数，让你自己开始删除和结束删除的标志。\n需要注意的是，一旦你的自定义函数返回 false，这两个函数都会立即返回当前结果。\n如果你想要双管齐下，首尾并进，strings.TrimFunc 更适合你。它其实就是在 strings.TrimLeftFunc 的基础上，再调用一次 strings.TrimRightFunc。\n自己实现 有时候，即便是这样，你的需求也不能得到满足。我想，那只能够说明你需要的不是 “Trim” 操作，而是更加具体的东西。\n比如，你有一个 nums 字符串，里面按序排列着 ‘1’ ～ ‘9’ 九个字符。\n现在，出于某种说不清道不明的无聊想法，你希望删除其中的偶数字符，保留奇数字符，该怎么实现呢？\n我不认为 strings 包提供了这种函数，并且，它最好永远也不要。\n你仍然固执地想要实现它，那么你可能会这样做：\n// removeEvenIndices 从给定的字符串中删除下标为偶数的字符，返回所有奇数组成的新字符串 func removeEvenIndices(nums string) string { // 使用 strings.Builder 高效拼接字符串  var result strings.Builder // 预分配内存空间，避免不必要的内存拷贝  result.Grow(9) for i, r := range nums { if (i+1)%2 == 1 { result.WriteRune(r) } } return result.String() } func TestRemoveEvenIndices(t *testing.T) { nums := \"123456789\" want := \"13579\" got := removeEvenIndices(nums) if got != want { t.Fatalf(`want \"%s\", but got \"%s\".`, want, got) } fmt.Println(got) } 后语 无论是什么编程语言，字符串操作都会是开发者关注的重点。毕竟程序的终极服务对象是人，而人眼不适合识别二进制数据。\n或许有一天，信息不需要以视觉的方式呈现，我们可以直接通过意念交流，不再需要语言。\n语言确实是优美的，但是意念沟通直接跳过了理解语言的步骤，岂不更美哉？\n  转载须知：本文使用 [CC BY-SA 4.0 国际协议][f] 进行许可，欢迎所有遵照协议的转载行为。\n作者：六开箱 链接：https://lkxed.github.io/posts/go-string-trim/  ","wordCount":"2406","inLanguage":"zh","datePublished":"2022-04-23T11:59:43+08:00","dateModified":"2022-04-23T11:59:43+08:00","author":{"@type":"Person","name":"六开箱"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lkxed.github.io/posts/go-string-trim/"},"publisher":{"@type":"Organization","name":"六开箱","logo":{"@type":"ImageObject","url":"https://lkxed.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://lkxed.github.io/ accesskey=h title="六开箱 (Alt + H)"><img src=https://lkxed.github.io/favicon.ico alt=logo aria-label=logo height=30>六开箱</a></div><ul id=menu><li><a href=https://lkxed.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://lkxed.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://lkxed.github.io/series/ title=系列><span>系列</span></a></li><li><a href=https://lkxed.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://lkxed.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go string：正确删除子串</h1><div class=post-meta><span title="2022-04-23 11:59:43 +0800 CST">2022 年 4 月 23 日</span>&nbsp;·&nbsp;2406 字&nbsp;·&nbsp;六开箱&nbsp;｜&nbsp;<a href=https://github.com/lkxed/ rel="noopener noreferrer" target=_blank>关注我🌟</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#strings-%e5%8c%85%e5%87%bd%e6%95%b0 aria-label="strings 包函数">strings 包函数</a><ul><li><a href=#%e5%88%a0%e9%99%a4%e7%a9%ba%e6%a0%bc aria-label=删除空格>删除空格</a></li><li><a href=#%e5%88%a0%e9%99%a4%e5%89%8d%e7%bc%80 aria-label=删除前缀>删除前缀</a></li><li><a href=#%e5%88%a0%e9%99%a4%e5%90%8e%e7%bc%80 aria-label=删除后缀>删除后缀</a></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%88%a0%e9%99%a4%e9%80%bb%e8%be%91 aria-label=自定义删除逻辑>自定义删除逻辑</a></li></ul></li><li><a href=#%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0 aria-label=自己实现>自己实现</a></li><li><a href=#%e5%90%8e%e8%af%ad aria-label=后语>后语</a></li></ul></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>在编写 [lctt-client][1] 时，我遇到了很多处理文件名的需求，其中最典型的莫过于 [生成符合规范的 Git 分支名称][2]。</p><p>在 Git 分支命名规则中，有几个条件是在限制开头和末尾不能包含指定的字符（串）。</p><p>这就要求我们必须把不符合规则的字符（串）替换掉，否则会因为分支名称不合法而无法创建该分支。</p><p>如果你用过 GitHub Desktop 的话，你可能会注意到：当你使用它创建分支，并输入一个不合规的名称时，它自动把名称里的“坏分子”删除或是替换成 <code>-</code>，然后给你提示。</p><p>如果我们自己要实现这一点的话，就必须使用到许多字符串操作的函数，其中就包括在字符串内指定的子串。</p><h2 id=strings-包函数>strings 包函数<a hidden class=anchor aria-hidden=true href=#strings-包函数>#</a></h2><p>Go 的内置包 <code>strings</code> 提供了一系列字符串操作的函数，其中有几个专门用来删除字符串中的指定字符，它们能帮上忙吗？</p><h3 id=删除空格>删除空格<a hidden class=anchor aria-hidden=true href=#删除空格>#</a></h3><p>首先，我们先来看看 <code>strings.TrimSpace</code> 函数，它可以将字符串首尾的空格“删除”，然后返回首尾不含空格的字符串。</p><p>之所以我要给“删除”加上引号，是因为空格并没有真的被删除，事实上，原来的字符串没有发生任何改变。</p><p>这个函数真正做的是：找到开头第一个非空格字符，然后找到末尾第一个非空格字符，记住它们的下标，然后返回介于它们之间的一个字符串切片。</p><p>事实上，strings 包内提供了所有字符串操作都是如此，因为 Go 中的 string 被设计为不可变类型。</p><p>无论如何，从结果来看，它是符合期望的。不过，我们可能用不上它，因为 Git 分支名称的任意位置都不许包含空格，不仅是首尾而已。</p><p>因此，在这种情况下，<code>strings.ReplaceAll</code> 会是更好的选择，它能够一次性删除包含所有的指定子串（只需要把它们替换为空串即可）。但它不是本文研究的重点，因此我们先把它搁置一旁。</p><h3 id=删除前缀>删除前缀<a hidden class=anchor aria-hidden=true href=#删除前缀>#</a></h3><p>如果你只是想要删除字符串开头的某个子串，你可能会选择这个函数，毕竟它乍一看非常符合你的需求。</p><p>但是，它并不是一个正确的选择。你可能会疑惑，尤其是当你曾经使用过它，并且也得到了符合预期的输出时。</p><p>考虑下面这个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// extractSentence 从一个给定的 quote（句子）中删除开头的 speaker（说话者），
</span></span></span><span class=line><span class=cl><span class=c1>// 从而提取出并返回一个修改后的新字符串
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>extractSentence</span><span class=p>(</span><span class=nx>quote</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>speaker</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>leading</span> <span class=o>:=</span> <span class=nx>speaker</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimLeft</span><span class=p>(</span><span class=nx>quote</span><span class=p>,</span> <span class=nx>leading</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestExtractSentence</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>quote</span> <span class=o>:=</span> <span class=s>&#34;LKXED: What do you think of it?&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>speaker</span> <span class=o>:=</span> <span class=s>&#34;LKXED&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>want</span> <span class=o>:=</span> <span class=s>&#34;What do you think of it?&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>got</span> <span class=o>:=</span> <span class=nf>extractSentence</span><span class=p>(</span><span class=nx>quote</span><span class=p>,</span> <span class=nx>speaker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>got</span> <span class=o>!=</span> <span class=nx>want</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Faltalf</span><span class=p>(</span><span class=s>&#34;Test failed. Want %s, but got %s.&#34;</span><span class=p>,</span> <span class=nx>want</span><span class=p>,</span> <span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个例子中，你写了一个提取句子的函数，还有针对它的单元测试。</p><p>你发现自己果然可以得到预期输出 “What do you think of it?”，你兴高采烈地开始基于它实现新的功能。</p><p>直到有一天，你的程序传进来一个不凑巧的 quote，内容是 “LKXED: Looks good to me.”，猜猜你最终会得到什么？</p><p>出人意料地，你得到了 “ooks good to me.”，开头的 “L” 被某种神秘力量吃掉了。</p><p>这是怎么回事呢？</p><p>仔细看 <code>strings.TrimLeft</code> 的函数注释，你就会发现，它并不是在删除某个指定的前缀子串，而是在删除某个指定的字符集合：</p><blockquote><p>// TrimLeft returns a slice of the string s with all leading<br>// Unicode code points contained in cutset removed.<br>//<br>// To remove a prefix, use TrimPrefix instead.</p></blockquote><p>具体来说，它会从第一个字符开始，按序逐个检查当前字符是否属于给定的字符集合，直到找到一个不满足条件的字符为止，然后返回字符串的剩余部分。</p><p>它还好心地提示了我们，如果需要删除一个指定的前缀，我们应该使用 <code>strings.TrimPrefix</code> 函数。</p><p>将上述例子中的 <code>strings.TrimLeft</code> 修改为 <code>strings.TrimPrefix</code>，测试通过，打印出了符合预期的 “Looks good to me.”。</p><p>原来，<code>strings.TrimPrefix</code> 的不同之处在于，它是真的在匹配前缀子串，并且需要子串完全匹配才行，否则就会返回原字符串，徒劳无功。</p><h3 id=删除后缀>删除后缀<a hidden class=anchor aria-hidden=true href=#删除后缀>#</a></h3><p>经过了上面的教训，这是时候你应该能够正确地选择 <code>strings.TrimSuffix</code> 来完成这个功能。</p><p>值得指出的是，对于文件名而言，这里的“后缀”通常会是文件扩展名。</p><p>对于特定的某一类文件，它的扩展名通常是固定的，可如果你的应用涉及到多种类型的文件，你可能需要想办法获取它们的扩展名才行。</p><p>事实上，当涉及到“文件路径”时，<code>path</code> 包内的函数通常都是有帮助的。比如你可能会需要的 <code>path.Ext</code>。</p><p><code>path.Ext</code> 只做了一件事：获取文件的扩展名。你可以结合它与 <code>strings.TrimSuffix</code> 来完成提取文件名的任务，就像下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// filenameWithoutExt 从 filename 中提取不含扩展名的文件名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>filenameWithoutExt</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ext</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>.</span><span class=nf>Ext</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>filename</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSuffix</span><span class=p>(</span><span class=nx>filename</span><span class=p>,</span> <span class=nx>ext</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>filename</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestFilenameWithoutExt</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>filename</span> <span class=o>:=</span> <span class=s>&#34;The Go Programming Language.pdf&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>want</span> <span class=o>:=</span> <span class=s>&#34;The Go Programming Language&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>got</span> <span class=o>:=</span> <span class=nf>filenameWithoutExt</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>got</span> <span class=o>!=</span> <span class=nx>want</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>`want &#34;%s&#34;, but got &#34;%s&#34;.`</span><span class=p>,</span> <span class=nx>want</span><span class=p>,</span> <span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=自定义删除逻辑>自定义删除逻辑<a hidden class=anchor aria-hidden=true href=#自定义删除逻辑>#</a></h3><p>如果你既不想要删除前后缀，也不想要删除指定的首尾字符集合，那么，你可以试试 <code>strings.TrimLeftFunc</code> 和 <code>strings.TrimRightFunc</code>。</p><p>这两个函数都支持让你提供一个 <code>func(r rune) bool</code> 函数，让你自己开始删除和结束删除的标志。</p><p>需要注意的是，一旦你的自定义函数返回 <code>false</code>，这两个函数都会立即返回当前结果。</p><p>如果你想要双管齐下，首尾并进，<code>strings.TrimFunc</code> 更适合你。它其实就是在 <code>strings.TrimLeftFunc</code> 的基础上，再调用一次 <code>strings.TrimRightFunc</code>。</p><h2 id=自己实现>自己实现<a hidden class=anchor aria-hidden=true href=#自己实现>#</a></h2><p>有时候，即便是这样，你的需求也不能得到满足。我想，那只能够说明你需要的不是 “Trim” 操作，而是更加具体的东西。</p><p>比如，你有一个 <code>nums</code> 字符串，里面按序排列着 &lsquo;1&rsquo; ～ &lsquo;9&rsquo; 九个字符。</p><p>现在，出于某种说不清道不明的无聊想法，你希望删除其中的偶数字符，保留奇数字符，该怎么实现呢？</p><p>我不认为 <code>strings</code> 包提供了这种函数，并且，它最好永远也不要。</p><p>你仍然固执地想要实现它，那么你可能会这样做：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// removeEvenIndices 从给定的字符串中删除下标为偶数的字符，返回所有奇数组成的新字符串
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>removeEvenIndices</span><span class=p>(</span><span class=nx>nums</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用 strings.Builder 高效拼接字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>result</span> <span class=nx>strings</span><span class=p>.</span><span class=nx>Builder</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 预分配内存空间，避免不必要的内存拷贝
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>result</span><span class=p>.</span><span class=nf>Grow</span><span class=p>(</span><span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>result</span><span class=p>.</span><span class=nf>WriteRune</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestRemoveEvenIndices</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>nums</span> <span class=o>:=</span> <span class=s>&#34;123456789&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>want</span> <span class=o>:=</span> <span class=s>&#34;13579&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>got</span> <span class=o>:=</span> <span class=nf>removeEvenIndices</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>got</span> <span class=o>!=</span> <span class=nx>want</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>`want &#34;%s&#34;, but got &#34;%s&#34;.`</span><span class=p>,</span> <span class=nx>want</span><span class=p>,</span> <span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=后语>后语<a hidden class=anchor aria-hidden=true href=#后语>#</a></h2><p>无论是什么编程语言，字符串操作都会是开发者关注的重点。毕竟程序的终极服务对象是人，而人眼不适合识别二进制数据。</p><p>或许有一天，信息不需要以视觉的方式呈现，我们可以直接通过意念交流，不再需要语言。</p><p>语言确实是优美的，但是意念沟通直接跳过了理解语言的步骤，岂不更美哉？</p><hr><blockquote><p>转载须知：本文使用 [CC BY-SA 4.0 国际协议][f] 进行许可，欢迎所有<strong>遵照协议</strong>的转载行为。<br>作者：<a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer">六开箱</a><br>链接：<a href=https://lkxed.github.io/posts/go-string-trim/ target=_blank rel="noopener noreferrer">https://lkxed.github.io/posts/go-string-trim/</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://lkxed.github.io/tags/go/>Go</a></li><li><a href=https://lkxed.github.io/tags/string/>String</a></li><li><a href=https://lkxed.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/>源码阅读</a></li><li><a href=https://lkxed.github.io/tags/%E6%95%99%E7%A8%8B/>教程</a></li></ul><nav class=paginav><a class=prev href=https://lkxed.github.io/posts/redis-persistence-pros-cons/><span class=title>« 上一页</span><br><span>Redis 持久化：RDB 与 AOF 的优缺点</span></a>
<a class=next href=https://lkxed.github.io/posts/almalinux-9-0-beta-release/><span class=title>下一页 »</span><br><span>AlmaLinux 9.0 测试版发布：与 RHEL 9 同步</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=lkxed/lkxed.github.io data-repo-id=R_kgDOHF00eA data-category=Announcements data-category-id=DIC_kwDOHF00eM4COXzh data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><div class=social-icons><a href=https://github.com/lkxed/ target=_blank rel="noopener noreferrer me" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://space.bilibili.com/88033726/ target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" xmlns="http://www.w3.org/2000/svg"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg></a></div><span>&copy; 2022 <a href=https://lkxed.github.io/>六开箱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/lkxed/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>